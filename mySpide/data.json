[{"title":"","content":""},{"title":"gulp安装后提示gulp不是内部命令或外部命令","content":"Fractal公司积极参与了数个流行Node.js模块的开发，它最近发布了一个新的构建系统gulp，希望能够取代Grunt，成为最流行的JavaScript任务运行器。\r\n\r\n根据gulp的文档，它努力实现的主要特性是：\r\n\r\n易于使用：采用代码优于配置策略，gulp让简单的事情继续简单，复杂的任务变得可管理。\r\n高效：通过利用node.js强大的流，不需要往磁盘写中间文件，可以更快地完成构建。\r\n高质量：gulp严格的插件指导方针，确保插件简单并且按你期望的方式工作。\r\n易于学习：通过把API降到最少，你能在很短的时间内学会gulp。构建工作就像你设想的一样：是一系列流管道。\r\nGulp通过流和代码优于配置策略来尽量简化任务编写的工作。这看起来有点“像jQuery”的方法，把动作串起来创建构建任务。早在UNIX的初期，流就已经存在了。流在Node.js生态系统中也扮演了重要的角色，因此用gulp编写任务也可看作是用Node.js编写任务。当使用流时，gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。gulp采用代码优于配置的策略，让简单的事情继续简单，将复杂的任务变得可管理。\r\n\r\n【以上文字全是摘自http://www.infoq.com/cn/news/2014/02/gulp】\r\n\r\n说以上文字主要是为了说明，在win7 64位操作系统下安装了nodejs后，按http://gulpjs.com/说明\r\n1. Install gulp globally:\r\n\r\n$ npm install --global gulp\r\n2. Install gulp in your project devDependencies:\r\n\r\n$ npm install --save-dev gulp\r\n3. Create a gulpfile.js at the root of your project:\r\n\r\nvar gulp = require('gulp');\r\n\r\ngulp.task('default', function() {\r\n  // place code for your default task here\r\n});\r\n4. Run gulp:\r\n\r\n$ gulp\r\n提示gulp不是内部命令或外部命令！！！！！！\r\n\r\n解决办法：\r\nnpm install -g npm\r\nnpm install -g gulp\r\n\r\n如此即解决！！！"},{"title":"关于元素垂直居中","content":"\r.box1{display: table-cell; vertical-align: middle; height: 300px; width: 500px; background: red;}\r         .box1 .am{width: 50px; height:50px; background: blue;}复制代码\n\r\n恩，今天学习到了，记录一下，大神勿喷"},{"title":"js原生代码----处理图片加载等待问题（纯手写，不喜勿喷）","content":"\r\n/*\r\n*\r\n*        一个处理大图片加载速度慢的问题\r\n*        要先引入JQuery\r\n*        \r\n*        \r\n*/\r\n\r\n        //获得浏览器类型\r\n        var Browser=new Object(); \r\n        Browser.userAgent=window.navigator.userAgent.toLowerCase(); \r\n        Browser.ie=/msie/.test(Browser.userAgent); \r\n        Browser.Moz=/gecko/.test(Browser.userAgent); \r\n        \r\n        /*\r\n        *        图片加载\r\n        *\r\n        *        url:加载路径\r\n        *        callback:回调函数\r\n        *\r\n        */\r\n        function loadImage(url,callback) \r\n        {\r\n                var img = new Image();\r\n                img.src=url;\r\n                if(Browser.ie){\r\n                        img.onreadystatechange =function(){\r\n                        if(img.readyState==\"complete\"||img.readyState==\"loaded\"){\r\n                                        callback.call(img);\r\n                                        return;                                \r\n                                }\r\n                                callback.call(img);\r\n                }\r\n                }else if(Browser.Moz){\r\n                        img.onload=function(){\r\n                                if(img.complete==true){\r\n                                        callback.call(img);\r\n                                        return;\r\n                                }\r\n                                callback.call(img);        \r\n                        }\r\n                }\r\n        }\r\n        \r\n        /*\r\n        *         数据格式\r\n        *         注意：最后一条数据不能有末尾的逗号（,）\r\n        */\r\n        var imglist = [\r\n        /*\r\n        {index:0,name:\"百度图片1\",url:\"http://img.redocn.com/201010/3/599750_1286086064SSce.jpg\"},\r\n        {index:1,name:\"百度图片2\",url:\"http://pic2.ooopic.com/01/26/61/83bOOOPIC72.jpg\"},\r\n        {index:2,name:\"百度图片3\",url:\"http://pica.nipic.com/2007-11-12/20071112133257795_2.jpg\"},\r\n        {index:3,name:\"百度图片4\",url:\"http://www.leawo.cn/attachment/201402/19/1880530_1392807424l5gk.jpg\"}\r\n        */\r\n        ];\r\n        \r\n        /*\r\n        *        判断图片是否加载完毕\r\n        *\r\n        *        index:图片游标\r\n        *        imglist:集合\r\n        *        \r\n        *        这个方法一般都在页面中调用\r\n        */\r\n        var loadStart = function(list,fn){\r\n                if(list.length == 0){\r\n                        fn();\r\n                        return true;\r\n                }\r\n                var j = 0;\r\n                for(var i = 0; i<list.length;i++){\r\n                        loadImage(list.src,function(){\r\n                                j++;\r\n                                if(j == list.length){\r\n                                        fn();\r\n                                }\r\n                        });\r\n                }        \r\n        }\r\n        \r\n        //调用这个方法  就开始执行了\r\n        //loadStart();\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        "},{"title":"javascript中的闭包（Closure）","content":"首先什么是闭包 \r\n在百度上的解释：“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域） \r\n百度链接：http://baike.baidu.com/link?url=7rP9FiFWu25cE9mCe4OtTnAQwigny_dLTQcpTdF-VmP6pHgsPzyjTn1WGswLR04beABo7eYF6TVmWtqk2lsxxK \r\n在维基百科上的解释：在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 \r\n维基百科链接：http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29\r\n\r\n具体到javascript中具体的表现形式就是：\r\n 函数的嵌套，因为链式作用域(Scope Chain)，外层函数的参数与变量对内层函数是可见的。内层函数可以访问到外层函数的参数与变量\r\n\r\njavascript代码：\rfunction init() {\r  var name = \"Colsure\";\r  function displayName() {\r    alert(name);\r  }\r  displayName();\r}\rinit(); //Closure复制代码\n在上面带代码中displayName是一个inner function,它调用了在parent function(即init方法)里面定义的变量name(若displayName没有引用parent function 里定义的变量，则不构成一个闭包)。displayName就是一个闭包。\r\n\r\n现在对上面的代码进行些微的改动\r\njavascript代码：\rfunction init() {\r  var name = \"Colsure\";\r  function displayName() {\r    alert(name);\r  }\r  return displayName;\r}\rvar myFunc = init();\rmyFunc(); //Closure复制代码\n\r\n上面代码最大的区别是inner function(即dispalyName方法)在执行前，就在parent function里返回了。在通常的情况下函数的局部变量仅在函数执行的过程中可以用，一旦init()执行以后，我们可能会认为变量name会被理所当然的回收，但是结果发现该变量并没有被回收，执行myFunc()后还是会得到name的值为Closure。在这个时候myFunc方法就是一个闭包，上面说过函数和与其相关的引用环境组合而成的实体。环境由闭包创建时在作用域中的任何局部变量组成。这个时候我们的闭包由displayName以及闭包创建时候的存在的字符串\"Closure\"组成。\r\n\r\n\r\n对上面的两个例子总结javascript中闭包的作用：\r\n1.可以读取函数内部的变量。\r\n2.使外层函数的参数与变量常驻内存，不会因为javascript的回收机制被回收。原因是内层函数一般是全局的，导致内层函数一直在内存中，而内层函数依赖外层函数，导致外层函数也一直存在内存中\r\n\r\n现在一个综合的例子\r\njavascript代码：\rvar test = (function(){\r        var number = 0\r        function change(val){\r                number += val;\r        }\r        return {\r                add : function(){\r                        change(1);\r                },\r                sub : function(){\r                        change(-1);\r                },\r                value : function(){\r                        return number;\r                }\r        }\r})();\rtest.value();//0\rtest.add();\rtest.add();\rtest.value();//2\rtest.sub();\rtest.value()//1复制代码\n由上面的代码看出，我们可以取得匿名函数内部的变量number，number并不因为匿名函数的执行而销毁。\r\n\r\n我们使用闭包解决问题\r\njavascript代码：\r<html>\r\n        <head>\r\n        </head>\r\n        <body>\r\n                <ul>\r\n                        <li>1</li>\r\n                        <li>2</li>\r\n                        <li>3</li>\r\n                        <li>4</li>\r\n                </ul>\r\n                <script>\r\n                        var tag = document.getElementsByTagName('li');\r\n                        var length = tag.length;\r\n                        for(var i = 0; i < length;i++){\r\n                                tag[i].onclick = function(){\r\n                                        alert(i);\r\n                                }\r\n                        }\r\n                </script>\r\n        </body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n代码的目的是想点击相应的li,弹出相应的0,1,2,3 但是结果却是点击所有的li都弹出4，明显的不符合预期。\r\n在上面代码里因为javascript是异步执行的，等到触发onclick事件的时候,i早已经经过循环变为4了。\r\n我们可以使用闭包保存每一次循环时候的i值\r\njavascript 代码：\r<html>\r\n        <head>\r\n        \r\n        </head>\r\n        <body>\r\n                <ul>\r\n                        <li>1</li>\r\n                        <li>2</li>\r\n                        <li>3</li>\r\n                        <li>4</li>\r\n                </ul>\r\n                <script>\r\n                        var tag = document.getElementsByTagName('li');\r\n                        var length = tag.length;\r\n                        for(var i = 0; i < length;i++){\r\n                                (function(i){\r\n                                        tag[i].onclick = function(){\r\n                                                alert(i);\r\n                                        }\r\n                                })(i);\r\n                        }\r\n                </script>\r\n        </body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n\r\n我们在onclick 执行方法外面加一个匿名函数，匿名函数(这个时候匿名函数是 parent function)接受参数i,内部函数引用这个i，这个时候onclick 是一个闭包。\r\n每一次循环的时候当前的i值都被内部函数引用，所以每次的i值都在内存中，我们可以得到预期的结果0,1,2,3。\r\n\r\n最后闭包在没有必要的情况下不建议使用，闭包对脚本的性能有负面的影响，包括处理速度和内存消耗。"},{"title":"2015-06-01","content":"HTML+CSS\r\n1.对WEB标准以及W3C的理解与认识\r\n标 签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访 问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；\r\n \r\n2.xhtml和html有什么区别\r\nHTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言\r\n最主要的不同：\r\nXHTML 元素必须被正确地嵌套。\r\nXHTML 元素必须被关闭。\r\n标签名必须用小写字母。\r\nXHTML 文档必须拥有根元素。\r\n \r\n3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?\r\n用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档\r\n加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug\r\n \r\n4.行内元素有哪些？块级元素有哪些？CSS的盒模型？\r\n块级元素：div p h1 h2 h3 h4 form ul\r\n行内元素: a b br i span input select\r\nCss盒模型:内容，border ,margin，padding\r\n \r\n5.CSS引入的方式有哪些? link和@import的区别是?\r\n内联 内嵌 外链 导入   \r\n区别 ：同时加载\r\n       前者无兼容性，后者CSS2.1以下浏览器不支持\r\n   Link 支持使用javascript改变样式，后者不可\r\n \r\n6.CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先级高？\r\n标签选择符  类选择符 id选择符\r\n继承不如指定   Id>class>标签选择\r\n后者优先级高\r\n \r\n7.前端页面有哪三层构成，分别是什么？作用是什么？\r\n结构层 Html 表示层 CSS 行为层 js\r\n \r\n8.css的基本语句构成是？\r\n选择器{属性1:值1;属性2:值2;……}\r\n \r\n9.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?\r\nIe(Ie内核)  火狐（Gecko） 谷歌（webkit） opear(Presto)\r\n \r\n10.写出几种IE6 BUG的解决方法\r\n1.双边距BUG float引起的  使用display\r\n2.3像素问题 使用float引起的 使用dislpay:inline -3px  \r\n3.超链接hover 点击后失效  使用正确的书写顺序 link visited hover active\r\n4.Ie z-index问题 给父级添加position:relative\r\n5.Png 透明 使用js代码 改\r\n6.Min-height 最小高度 ！Important 解决’\r\n7.select 在ie6下遮盖 使用iframe嵌套\r\n8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）\r\n \r\n11.<img>标签上title与alt属性的区别是什么？\r\nAlt 当图片不显示是 用文字代表。\r\nTitle 为该属性提供信息\r\n \r\n12.描述css reset的作用和用途。\r\nReset重置浏览器的css默认属性        浏览器的品种不同，样式不同，然后重置，让他们统一\r\n \r\n13.解释css sprites，如何使用。\r\nCss 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量\r\n \r\n14.浏览器标准模式和怪异模式之间的区别是什么？\r\n盒子模型 渲染模式的不同\r\n使用 window.top.document.compatMode 可显示为什么模式\r\n \r\n15.你如何对网站的文件和资源进行优化？期待的解决方案包括：\r\n文件合并\r\n文件最小化/文件压缩\r\n使用CDN托管\r\n缓存的使用\r\n \r\n16.什么是语义化的HTML？\r\n直观的认识标签  对于搜索引擎的抓取有好处\r\n \r\n17.清除浮动的几种方式，各自的优缺点\r\n1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）\r\n2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）\r\n3.是用afert伪元素清除浮动(用于非IE浏览器)\r\n \r\nJavascript\r\n1.javascript的typeof返回哪些数据类型\r\nObject number function boolean underfind\r\n \r\n2.例举3种强制类型转换和2种隐式类型转换？\r\n强制（parseInt,parseFloat,number）\r\n隐式（== - ===）\r\n \r\n3.split() join() 的区别\r\n前者是切割成数组的形式，后者是将数组转换成字符串\r\n \r\n4.数组方法pop() push() unshift() shift()\r\nPush()尾部添加 pop()尾部删除\r\nUnshift()头部添加  shift()头部删除\r\n \r\n5.事件绑定和普通事件有什么区别\r\n \r\n6.IE和DOM事件流的区别\r\n1.执行顺序不一样、\r\n2.参数不一样\r\n3.事件加不加on\r\n4.this指向问题\r\n \r\n7.IE和标准下有哪些兼容性的写法\r\nVar ev = ev || window.event\r\ndocument.documentElement.clientWidth || document.body.clientWidth\r\nVar target = ev.srcElement||ev.target\r\n \r\n8.ajax请求的时候get 和post方式的区别\r\n一个在url后面 一个放在虚拟载体里面\r\n有大小限制\r\n安全问题\r\n应用不同 一个是论坛等只需要请求的，一个是类似修改密码的\r\n \r\n9.call和apply的区别\r\nObject.call(this,obj1,obj2,obj3)\r\nObject.apply(this,arguments)\r\n \r\n10.ajax请求时，如何解释json数据\r\n使用eval parse 鉴于安全性考虑 使用parse更靠谱\r\n11.b继承a的方法\r\n \r\n12.写一个获取非行间样式的函数\r\nfunction oSort(arr)\r\n\r\n        {\r\n\r\n            var result ={};\r\n\r\n            var newArr=[];\r\n\r\n            for(var i=0;i<arr.length;i++)\r\n\r\n            {\r\n\r\n                if(!result[arr])\r\n\r\n                {\r\n\r\n                    newArr.push(arr)\r\n\r\n                    result[arr]=1\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return newArr\r\n\r\n        }\r\n23.排序算法\r\n快速排序function oSort(arr)\r\n\r\n        {\r\n\r\n            if(arr.length<=1)\r\n\r\n            {\r\n\r\n                return arr\r\n\r\n            }\r\n\r\n            var left=[];\r\n\r\n            var right=[];\r\n\r\n            var oNum = Math.floor(arr.length/2);\r\n\r\n            var oNumVode = arr.splice(oNum,1);\r\n\r\n            for(var i=0;i<arr.length;i++)\r\n\r\n            {\r\n\r\n                if(arr<oNumVode)\r\n\r\n                {\r\n\r\n                    left.push(arr)\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    right.push(arr)\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return oSort(left).concat([oNumVode],oSort(right))\r\n\r\n        }\r\n\r\n冒泡排序 var array = [5, 4, 3, 2, 1];\r\n\r\nvar temp = 0;\r\n\r\nfor (var i = 0; i < array.length; i++)\r\n\r\n{\r\n\r\nfor (var j = 0; j < array.length - i; j++)\r\n\r\n{\r\n\r\nif (array[j] > array[j + 1])\r\n\r\n{\r\n\r\ntemp = array[j + 1];\r\n\r\narray[j + 1] = array[j];\r\n\r\narray[j] = temp;\r\n\r\n}\r\n\r\n}\r\n\r\n}"},{"title":"【angularJS】Directive","content":"Directive 指令：实现主义化标签，即能让浏览器识别自定义的dom元素。\r\n\r\n示例：\r<html>\r<head>\r</head>\r<body>\r<myelement><myelement>\r</body>\r</html>复制代码\n\r\n<myElement>是浏览器不能识别的元素。那怎么样才能让浏览器识别这样的自定义元素呢，这就是directive要做的事，原理就是替换成浏览器能识别的东东......\r\n\r\n话不多说，上代码:\r\n\rapp.directive(\"myelement\",function(){\r    return {\r        restrict: 'EAMC'\r        ,template: '<div><span>my name is {{name}}</span></div>'\r    }\r})复制代码\n\r\n页面解析html:\r\n\r <myelement>\r<div>\r<span class=\"ng-binding\">\rmy name is Li Lei\r</span>\r</div>\r</myelement>\r复制代码\n\r\n这样浏览器就可以解析到并展示到页面上了。\r\n\r\n下面对每个参数进行一些说明：\r\n\r\n1、restrict：t配置可以按如下方式设置:\r\n         - 'A' 仅匹配属性名字\r\n         - 'E' 仅匹配元素名字\r\n         - 'C'仅匹配样式名\r\n        可以混合使用，或的关系，如'AE'\r\n\r\n        对应HTML页面元素为：\r\r        <div myelement></div>\r        <myelement></myelement>\r        <div class=\"myelement\"></div>\r复制代码\n\r\n2、template:模版内容\r\n\r\n2.1、templateUrl：引用模板文件\r\n        templateUrl 也可以是一个函数，它返回的 HTML 模板的 URL 被加载指令中的取用。Angular将调用 templateUrl 函数带两个参数： theelement ，该directive元素，和 一个 attr 对象与该元素相关联；\r\n        注意：在scope初始化之前请求template,不能从 templateUrl 函数中访问到scope变量。\r\n        示例：\r\nHTML:\r<myelement type=\"2\">\r                        <div>This is old one.</div>\r                </myelement>复制代码\nJS:\rapp.directive(\"myelement\", function() {\r        return {\r                restrict: 'E',\r                templateUrl:function(e,attr){\r                    return 'test'+attr.type+'.html';\r                }\r        }\r})复制代码\n\r\n3、replace:如果设置为true，那么模版将会替换当前元素，而不是作为子元素添加到当前元素中。（注：为true时，模版必须有一个根节点）\r\n\r\n示例：\rapp.directive(\"myelement\", function() {\r        return {\r                restrict: 'E',\r                replace:true,\r                template: '<div><span>my name is {{name}}</span></div>'\r        }\r})复制代码\n\r\n输出 ：\r\n\r<div>\r                        <div><span class=\"ng-binding\">my name is Li Lei</span></div>\r                </div>复制代码\n\r\n\r\n\r\n4、transclude：简单的讲就是自定义标签myelement内部还有子元素的时候，transclude为true时保留内部元素，为 false时不保留内部元素。要配合ngTransclude使用，在模板中留一个元素加上ng-transclude用于存放原内部元素。\r\n\r\n示例：\rapp.directive(\"myelement\", function() {\r        return {\r                restrict: 'E',\r                //replace:true,\r                transclude:true,\r                template: '<div><span>my name is {{name}}</span><span ng-transclude></span></div>'\r        }\r})复制代码\n\r\n输出：\r\n\r<myelement><div><span class=\"ng-binding\">my name is Li Lei</span><span ng-transclude=\"\">\r                        <div class=\"ng-scope\">This is old one.</div>\r                </span></div></myelement>复制代码\n\r\n\r\n\r\n明天继续，回家 ...."},{"title":"基于jQuery遮罩图片hover翻转效果","content":"基于jQuery遮罩图片hover翻转效果。这是一款基于jQuery+css3实现的鼠标经过遮罩图片翻转特效。效果图如下：在线预览   源码下载实现的代码。html代码：<div class=\"index_hd\">\r    <div class=\"fr hd_r major-list-outer\">\r        <ul class=\"major-list\">\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1413775760-7544.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-left\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1400684346-4329.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-right\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1413775714-2418.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1411890878-8918.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1413775714-2418.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1400684434-4609.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1428032296-8158.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r            <li class=\"major-item\">\r                <a href=\"http://www.w2bc.com/\">\r                    <span class=\"txt-hide front-face\">\r                        <img src=\"images/1405250374-3685.jpg\" width=\"294\" height=\"267\">\r                    </span>\r                    <span class=\"back-face to-top\"></span>\r                </a>\r            </li>\r        </ul>\r    </div>\r</div>复制代码via：http://www.w2bc.com/Article/39562\r\n"},{"title":"placeholder插件","content":"由于ie8不支持placeholder属性，所以用jquery写了个placeholder插件\r\n直接上代码：\r<!DOCTYPE html>\r<html>\r<head lang=\"en\">\r    <meta charset=\"UTF-8\">\r    <title>placeholder插件</title>\r    <style>\r        .box{\r            padding: 10px;\r            position: relative;\r        }\r    </style>\r</head>\r<body>\r<div class=\"box\">\r    <textarea class=\"textarea\"></textarea>\r</div>\r<div class=\"box\">\r    <input type=\"text\" class=\"input\"/>\r</div>\r<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.8.2.js\"></script>\r<script>\r    /**\r     *\r     * @param string text 显示的文本\r     * @param string top 显示文本距离输入框顶端间距\r     * @param string  left 显示文本距离输入框左端间距\r     */\r    $.fn.placeholder=function(text,top,left) {\r        var sTop =  top || \"10px\";\r        var sLeft = left || \"10px\";\r        var self = $(this);\r        //创建一个元素用来装载placeholder文本\r        var spanElement = $('<span>'+text+'</span>');\r        //设置样式\r        spanElement.css({\r           position: 'absolute',\r           left: sLeft,\r           top: sTop,\r           color: '#999'\r        });\r        self.parent().append(spanElement);\r\r        self.bind({\r            blur:function() {\r                 if(self.val() !== \"\"){\r                    spanElement.hide();\r                }else{\r                    spanElement.show();\r                }\r            },\r            focus:function() {\r                spanElement.hide();\r            }\r        });\r        spanElement.click(function() {\r            self.focus();\r        })\r\r    };\r    //应用$(selector).placeholder(text,top,left)\r    $('.textarea').placeholder(\"请输入\",\"14px\",\"14px\");\r    $('.input').placeholder(\"请输入文本\");\r</script>\r</body>\r</html>复制代码\n\r<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title>placeholder插件</title>\r\n    <style>\r\n        .box{\r\n            padding: 10px;\r\n            position: relative;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<div class=\"box\">\r\n    <textarea class=\"textarea\"></textarea>\r\n</div>\r\n<div class=\"box\">\r\n    <input type=\"text\" class=\"input\"/>\r\n</div>\r\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.8.2.js\"></script>\r\n<script>\r\n    /**\r\n     *\r\n     * @param string text 显示的文本\r\n     * @param string top 显示文本距离输入框顶端间距\r\n     * @param string  left 显示文本距离输入框左端间距\r\n     */\r\n    $.fn.placeholder=function(text,top,left) {\r\n        var sTop =  top || \"10px\";\r\n        var sLeft = left || \"10px\";\r\n        var self = $(this);\r\n        //创建一个元素用来装载placeholder文本\r\n        var spanElement = $('<span>'+text+'</span>');\r\n        //设置样式\r\n        spanElement.css({\r\n           position: 'absolute',\r\n           left: sLeft,\r\n           top: sTop,\r\n           color: '#999'\r\n        });\r\n        self.parent().append(spanElement);\r\n\r\n        self.bind({\r\n            blur:function() {\r\n                if(self.val() !== \"\"){\r\n                    spanElement.hide();\r\n                }else{\r\n                    spanElement.show();\r\n                }\r\n            },\r\n            focus:function() {\r\n                spanElement.hide();\r\n            }\r\n        });\r\n        spanElement.click(function() {\r\n            self.focus();\r\n        })\r\n\r\n    };\r\n    //应用$(selector).placeholder(text,top,left)\r\n    $('.textarea').placeholder(\"请输入\",\"14px\",\"14px\");\r\n    $('.input').placeholder(\"请输入文本\");\r\n</script>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com"},{"title":"常用JavaScript代码","content":"一、取URL中的参数\r    function getParameterByName(name) {\r        var match = RegExp('[?&]' + name + '=([^&]*)')\r                        .exec(window.location.search);\r        return match && decodeURIComponent(match[1].replace(/\\+/g, ' '));\r    }复制代码\n二、正则分组\r\n\r    var testStr=\"<div><img src='/a.jpg' alt='' /><span>test</span><img src='/b.jpg' alt='' /><span>TTest</span><img src='/c.png' alt='' /></div>\";\r    var reg=/<img\\ssrc='(.*?)'\\s+alt=''\\s*\\/>/g;\r    var match=reg.exec(testStr),results=[];\r    while(match != null){\r        results.push(match[1]);\r        match=reg.exec(testStr);\r    }\r    console.log(results);\r    /*\r    Array [\"/a.jpg\", \"/b.jpg\", \"/c.png\"]\r    */复制代码\n\r\n三、为什么parseInt(1/0,19)的结果为18\r\n\r\n　　1/0的结果是Infinity，所以parseInt(1/0,19)等同于parseInt(\"Infinity\",19)，而在19进制中：\r\n\r\n19进制       10进制\r\n--------------------\r\n   0            0\r\n   1            1\r\n   2            2\r\n   3            3\r\n   4            4\r\n   5            5\r\n   6            6\r\n   7            7\r\n   8            8\r\n   9            9\r\n   a            10\r\n   b            11\r\n   c            12\r\n   d            13\r\n   e            14\r\n   f             15\r\n   g            16\r\n   h            17\r\n   i             18\r\n　　i表示18，所以parseInt(1/0,19)的结果为18。\r\n\r\n四、jQuery中获取设置checkbox选中状态\r\n\r\n　　由于在jQuery1.6以后.attr(\"checked\")的返回结果是 checked，所以一般用下面两种方法获取选中状态：\r\n\r    $(\"#checkboxID\").is(\":checked\");\r\r    //jQuery 1.6 +\r    $(\"#checkboxID\").prop(\"checked\");\r    　　选中checkbox：\r\r    //jQuery 1.6+\r    $(\"#checkboxID\").prop(\"checked\", true);\r    $(\"#checkboxID\").prop(\"checked\", false);\r\r    //jQuery 1.5 and below\r    $('#checkboxID').attr('checked','checked')\r    $('#checkboxID').removeAttr('checked')\r复制代码\n\r\n五、jQuery中判断一个元素是否存在\r\n\r    if ($(selector).length)复制代码\n\r\n六、用JavaScript对URL进行编码\r\n\r    var myUrl = \"http://example.com/index.html?param=1&anotherParam=2\";\r    var myOtherUrl = \"http://example.com/index.html?url=\" + encodeURIComponent(myUrl);复制代码\n\r\n七、jQuery中event.preventDefault() 与 return false 的区别\r\n\r    //Demo1 event.preventDefault()\r    $('a').click(function (e) {\r        // custom handling here\r\r        e.preventDefault();\r    });\r\r    //Demo2 return false\r    $('a').click(function () {\r        // custom handling here\r\r        return false;\r    };\r    　　jQuery中return false相当于同时调用e.preventDefault 和 e.stopPropagation。复制代码\n\r\n　　要注意的是，在原生js中，return false仅仅相当于调用了e.preventDefault。\r\n\r\n八、JavaScript检查一个字符串是否为空最简单的方法\r\n\r\n   if (strValue) {\r        //do something\r    }复制代码\n\r\n九、用JavaScript添加和删除class\r\n\r    //Add Class\r    document.getElementById(\"MyElement\").className += \" MyClass\";\r\r    //Remove Class\r    document.getElementById(\"MyElement\").className = document.getElementById(\"MyElement\").className.replace(/(?:^|\\s)MyClass(?!\\S)/,'');复制代码\n\r\n十、在jQuery中取消一个ajax请求\r\r    var xhr = $.ajax({\r        type: \"POST\",\r        url: \"test.php\",\r        data: \"name=test\",\r        success: function(msg){\r           alert( msg );\r        }\r    });\r复制代码\n\r\n    //取消请求\r    xhr.abort()复制代码\n\r\n　　要注意的是，在ajax请求未响应之前可以用xhr.abort()取消，但如果请求已经到达了服务器端，这样做的结果仅仅是让浏览器不再监听这个请求的响应，但服务器端仍然会进行处理。\r\n\r\n十一、JavaScript删除数组中的项 delete vs splice\r\r    var myArray=[\"a\",\"b\",\"c\"];\r    delete myArray[0];\r    for(var i=0,j=myArray.length;i<j;i++){\r        console.log(myArray<i>);\r        /*\r        undefined\r        b\r        c\r        */\r    }\r\r    var myArray2=[\"a\",\"b\",\"c\"];\r    myArray2.splice(0,1);\r    for(var i=0,j=myArray2.length;i<j;i++){\r        console.log(myArray2<i>);\r        /*\r        b\r        c\r        */\r    }</i></i>复制代码\n\r\n\r\n　　上面的代码已经说明区别了，一个是设置为undefined，一个是真正的删除了。\r\n\r\n十二、JavaScript中16进制与10进制相互转换\r\n\r    var sHex=(255).toString(16);//ff\r    var iNum=parseInt(\"ff\",16);//255\r复制代码\n\r\n十三、JavaScript多行字符串\r\n\r\n　　如何在JavaScript中方便地写一个多行字符串呢，有三种方案，你自己选吧：\r\n\r    //one\r    var testHtml=\"a\"+\r    \"b\"+\r    \"c\";\r\r    //two\r    var testHtml2=\"a\\\r    b\\\r    c\";\r\r    //three\r    var testHtml3=[\"a\",\r    \"b\",\r    \"c\"].join(\"\");复制代码\n\r\n十四、JavaScript中!!操作符是什么\r\n\r    console.log(!!10);//true\r    console.log(!!0);//false\r    console.log(!!\"abc\");//true\r    console.log(!!\"\");//false复制代码\n\r\n　　简单地说就是把右侧的值转为bool值\r\n\r\n十五、JavaScript实现endsWith\r\n\r    String.prototype.endsWith = function(suffix) {\r        return this.indexOf(suffix, this.length - suffix.length) !== -1;\r    };\r\r    //or\r    function endsWith(str, suffix) {\r        return str.indexOf(suffix, str.length - suffix.length) !== -1;\r    }复制代码\n\r\n十六、JavaScript中克隆对象\r\n\r    function clone(obj) {\r        // Handle the 3 simple types, and null or undefined\r        if (null == obj || \"object\" != typeof obj) return obj;\r\r        // Handle Date\r        if (obj instanceof Date) {\r            var copy = new Date();\r            copy.setTime(obj.getTime());\r            return copy;\r        }\r\r        // Handle Array\r        if (obj instanceof Array) {\r            var copy = [];\r            for (var i = 0, var len = obj.length; i < len; ++i) {\r                copy<i> = clone(obj<i>);\r            }\r            return copy;\r        }\r\r        // Handle Object\r        if (obj instanceof Object) {\r            var copy = {};\r            for (var attr in obj) {\r                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r            }\r            return copy;\r        }\r\r        throw new Error(\"Unable to copy obj! Its type isn't supported.\");\r    }\r</i></i>复制代码\n\r\n\r\n十七、JavaScript字符与ASCII码间的转换\r\n\r    console.log(\"\\n\".charCodeAt(0));//10\r    console.log(String.fromCharCode(65));//A复制代码\n\r\n十八、JavaScript中浮点数的相等判断不能用 ==\r\n\r    console.log(0.1+0.2 == 0.3);//false\r    console.log(Math.abs(0.1+0.2 - 0.3) < 0.000001);//true复制代码\n\r\n　　如上所示，浮点数相等判断要用差的绝对值小于某一个数来判断。至于原因可以参考这里：http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\r\n\r\n十九、JavaScript中base64编码\r\r    var Base64 = {\r\r    // private property\r    _keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\r\r    // public method for encoding\r    encode : function (input) {\r        var output = \"\";\r        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r        var i = 0;\r\r        input = Base64._utf8_encode(input);\r\r        while (i < input.length) {\r\r            chr1 = input.charCodeAt(i++);\r            chr2 = input.charCodeAt(i++);\r            chr3 = input.charCodeAt(i++);\r\r            enc1 = chr1 >> 2;\r            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r            enc4 = chr3 & 63;\r\r            if (isNaN(chr2)) {\r                enc3 = enc4 = 64;\r            } else if (isNaN(chr3)) {\r                enc4 = 64;\r            }\r\r            output = output +\r            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\r            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\r\r        }\r\r        return output;\r    },\r\r    // public method for decoding\r    decode : function (input) {\r        var output = \"\";\r        var chr1, chr2, chr3;\r        var enc1, enc2, enc3, enc4;\r        var i = 0;\r\r        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\r\r        while (i < input.length) {\r\r            enc1 = this._keyStr.indexOf(input.charAt(i++));\r            enc2 = this._keyStr.indexOf(input.charAt(i++));\r            enc3 = this._keyStr.indexOf(input.charAt(i++));\r            enc4 = this._keyStr.indexOf(input.charAt(i++));\r\r            chr1 = (enc1 << 2) | (enc2 >> 4);\r            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r            chr3 = ((enc3 & 3) << 6) | enc4;\r\r            output = output + String.fromCharCode(chr1);\r\r            if (enc3 != 64) {\r                output = output + String.fromCharCode(chr2);\r            }\r            if (enc4 != 64) {\r                output = output + String.fromCharCode(chr3);\r            }\r\r        }\r\r        output = Base64._utf8_decode(output);\r\r        return output;\r\r    },\r\r    // private method for UTF-8 encoding\r    _utf8_encode : function (string) {\r        string = string.replace(/\\r\\n/g,\"\\n\");\r        var utftext = \"\";\r\r        for (var n = 0; n < string.length; n++) {\r\r            var c = string.charCodeAt(n);\r\r            if (c < 128) {\r                utftext += String.fromCharCode(c);\r            }\r            else if((c > 127) && (c < 2048)) {\r                utftext += String.fromCharCode((c >> 6) | 192);\r                utftext += String.fromCharCode((c & 63) | 128);\r            }\r            else {\r                utftext += String.fromCharCode((c >> 12) | 224);\r                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\r                utftext += String.fromCharCode((c & 63) | 128);\r            }\r\r        }\r\r        return utftext;\r    },\r\r    // private method for UTF-8 decoding\r    _utf8_decode : function (utftext) {\r        var string = \"\";\r        var i = 0;\r        var c = c1 = c2 = 0;\r\r        while ( i < utftext.length ) {\r\r            c = utftext.charCodeAt(i);\r\r            if (c < 128) {\r                string += String.fromCharCode(c);\r                i++;\r            }\r            else if((c > 191) && (c < 224)) {\r                c2 = utftext.charCodeAt(i+1);\r                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\r                i += 2;\r            }\r            else {\r                c2 = utftext.charCodeAt(i+1);\r                c3 = utftext.charCodeAt(i+2);\r                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r                i += 3;\r            }\r\r        }\r\r        return string;\r    }\r    }\r\r    //encode\r    Base64.encode(\"Test\"); //VGVzdA==\r\r    //decode\r    Base64.decode(\"VGVzdA==\"); // Test复制代码\n\r\n二十、jQuery中each跟map的区别\r\n　　each跟map都可以用来遍历Array或Object，区别是each不改变原来的Array或Object，map是操作给定的Array或Object返回一个新Array或Object。Demo:\r\r    var items = [1,2,3,4];\r\r    $.each(items, function() {\r      alert('this is ' + this);//alert 1,2,3,4\r    });\r\r    var newItems = $.map(items, function(i) {\r      return i + 1;\r    });\r    // newItems is [2,3,4,5]复制代码\n\r\n　　map会占用更多的内存，所以如果只是遍历建议用each。\r\n\r\n二十一、判断一个对象是否为数组\r\n\r    function isArray(obj){\r        return Object.prototype.toString.call(obj) == \"[object Array]\";\r    }复制代码\n\r\n　　不能用instanceof 和 constructor来判断，原因参考：http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\r\n\r\n二十二、通过原型继承创建一个新对象\r\n\r    function inherit(p){\r        if(!p){\r            throw TypeError(\"p is not an object or null\");\r        }\r        if(Object.create){\r            return Object.create(p);\r        }\r        var t=typeof p;\r        if(t !== \"object\" && t !== \"function\"){\r            throw TypeError(\"p is not an object or null\");\r        }\r        function f(){};\r        f.prototype=p;\r        return new f();\r    }复制代码非原创\r\n原文见：http://www.w3cfuns.com/blog-5455438-5406240.html\r\n"},{"title":"正则表达式的简单语法","content":"        \r\n        今晚研究了一下正则表达式，在网上查到一份讲的还不错的，我又稍微修改了一下，备份一下，如果有不对的地方，欢迎大家批评指正。\r\n        \r\n        一.正则表达式基本语法\r\n\r\n        1.两个特殊的符号'^'和'$'。他们的作用是分别指出一个字符串的开始和结束。\r\n        \r\n        例子：\r\n\r\n                \"^The\"：表示所有以\"The\"开始的字符串（\"There\"，\"The cat\"等）；\r\n                \"of despair$\"：表示所以以\"of despair\"结尾的字符串；\r\n                \"^abc$\"：表示开始和结尾都是\"abc\"的字符串——比如\"abc\"、“abcsdsfabc”；\r\n                \"notice\"：表示任何包含\"notice\"的字符串。//如果你不使用两个特殊字符，你就在表示要查找的串在被查找串的任意位置\r\n\r\n        2.'*'，'+'和'?'这三个符号，表示一个或一序列字符重复出现的次数。\r\n                *        表示        “没有或更多（任意次数）”\r\n                +        表示        “一次或更多(至少一次）”\r\n                ？        表示        “没有或一次（至多一次）”。\r\n\r\n        例子：\r\n\r\n                \"ab*\"：表示一个字符串有一个a后面跟着零个或若干个b。（\"a\", \"ab\", \"abbb\",……）；\r\n                \"ab+\"：表示一个字符串有一个a后面跟着至少一个b或者更多；\r\n                \"ab?\"：表示一个字符串有一个a后面跟着零个或者一个b；\r\n                \"a?b+$\"：表示在字符串的末尾有零个或一个a跟着一个或几个b。\r\n\r\n        另外一种表达方式，用大括号括起，用以表示重复次数的范围。\r\n\r\n        例子：\r\n                \"ab{2}\"：表示一个字符串有一个a跟着2个b（\"abb\"）；\r\n                \"ab{2,}\"：表示一个字符串有一个a跟着至少2个b；\r\n                \"ab{3,5}\"：表示一个字符串有一个a跟着3到5个b。\r\n\r\n        请注意，你必须指定范围的下限（如：\"{0,2}\"而不是\"{,2}\"）。这两种方式的对应关系\r\n                '*'        =        \"{0,}\"\r\n                '+'        =        \"{1,}\"\r\n                '?'        =        \"{0,1}\"\r\n        3.'|'，表示“或”操作\r\n\r\n        例子：\r\n                \"hi|hello\"：表示一个字符串里有\"hi\"或者\"hello\"；\r\n                \"(b|cd)ef\"：表示\"bef\"或\"cdef\"；\r\n                \"(a|b)*c\"：表示一串\"a\"\"b\"混合的字符串后面跟一个\"c\"；\r\n\r\n        4.'.'可以替代任何字符：\r\n\r\n        例子：\r\n                \"a.[0-9]\"：表示一个字符串有一个\"a\"后面跟着一个任意字符和一个数字；\r\n                \"^.{3}$\"：表示有任意三个字符的字符串（长度为3个字符）；\r\n\r\n        5.[]方括号表示某些字符允许在一个字符串的某一特定位置出现：\r\n\r\n        例子：\r\n                \"[ab]\"：表示一个字符串有一个\"a\"或\"b\"（相当于\"a|b\"）；\r\n                \"[a-d]\"：表示一个字符串包含小写的'a'到'd'中的一个（相当于\"a|b|c|d\"或者\"[abcd]\"）；\r\n                \"^[a-zA-Z]\"：表示一个以字母开头的字符串；\r\n                \"[0-9]%\"：表示一个百分号前有一位的数字；\r\n                \",[a-zA-Z0-9]$\"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。\r\n\r\n        你也可以在方括号里用'^'表示不希望出现的字符（这里与之前作用不同），'^'应在方括号里的第一位。（如：\"%[^a-zA-Z]%\"表示两个百分号中不应该出现字母）。\r\n\r\n        为了逐字表达，你必须在\"^.$()|*+?{\\\"这些字符前加上转移字符'\\'。请注意在方括号中，不需要转义字符。\r\n\r\n\r\n\r\n        二.正则表达式验证控制文本框的输入字符类型\r\n        1.只能输入数字和英文的： \r\n<input onkeyup=\"value=value.replace(/[\\W]/g,'') \" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\" ID=\"Text1\" NAME=\"Text1\">\r\n\r\n        2.只能输入数字的： \r\n<input onkeyup=\"value=value.replace(/[^\\d]/g,'') \" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\" ID=\"Text2\" NAME=\"Text2\">\r\n\r\n        3.只能输入全角的： \r\n<input onkeyup=\"value=value.replace(/[^\\uFF00-\\uFFFF]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\uFF00-\\uFFFF]/g,''))\" ID=\"Text3\" NAME=\"Text3\">\r\n\r\n        4.只能输入汉字的： \r\n<input onkeyup=\"value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\u4E00-\\u9FA5]/g,''))\" ID=\"Text4\" NAME=\"Text4\">\r\n\r\n\r\n        三.正则表达式的应用实例通俗说明\r\n \r\n*******************************************************************************\r\n\r\n        ^ 表示打头的字符要匹配紧跟^后面的规则\r\n\r\n        $ 表示打头的字符要匹配紧靠$前面的规则\r\n\r\n        [ ] 中的内容是可选字符集\r\n\r\n        [0-9] 表示要求字符范围在0-9之间\r\n\r\n        {1,20}表示数字字符串长度合法为1到20，即为[0-9]中的字符出现次数的范围是1到20次。\r\n\r\n         \\w：用于匹配字母，数字或下划线字符\r\n\r\n        \\d：用于匹配从0到9的数字；\r\n\r\n        [\\u4E00-\\u9FA5] ：中文字符集的范围\r\n\r\n        /^ 和 $/成对使用应该是表示要求整个字符串完全匹配定义的规则，而不是只匹配字符串中的一个子串。\r\n\r\n*******************************************************************************\r\n\r\n        //校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串\r\n\r\n        /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/\r\n\r\n*******************************************************************************\r\n\r\n        //校验用户姓名：只能输入1-30个以字母开头的字串\r\n\r\n        /^[a-zA-Z]{1,30}$/\r\n\r\n*******************************************************************************\r\n\r\n        //校验密码：只能输入6-20个字母、数字、下划线\r\n\r\n        /^(\\w){6,20}$/\r\n\r\n*******************************************************************************\r\n\r\n        //校验普通电话、传真号码：可以“+”或数字开头，可含有“-” 和 “ ”\r\n\r\n        /^[+]{0,1}(\\d){1,3}[ ]?([-]?((\\d)|[ ]){1,12})+$/\r\n\r\n        可以匹配的字符串如：+123 -999 999 ； +123-999 999 ；123 999 999 ；+123 999999等\r\n\r\n\r\n\r\n \r\n"},{"title":"移动端浏览器30坑","content":"Oprea Mini 加载页面后不会重绘 :target CSS指令。\r\n\r\nBlackberry OS6 的 SVG 字体支持糟透了\r\n\r\nBlackberry OS5 不支持:before/:after的 background-image\r\n\r\n设定-webkit-appearance会导致Android 4.0+ 影子DOM样式问题\r\n\r\niOS7 虚拟器： 无法清除Safari的cookies和数据\r\n\r\nAndroid默认浏览器键盘Resize事件问题\r\n\r\n后退时，iOS 禁用了iframe中的 Javascript\r\n\r\niOS 6-7 处理viewport相关的单位很诡异\r\n\r\nspinner开启时，轻触与选中标签会导致键盘闪动\r\n\r\nAndroid 4+ 上使用XHR2 发送Blob时发送的body为空\r\n\r\nAndroid上canvas.toDataURL('image/jpeg')返回image/png on Android\r\n\r\nGalaxy Nexus上的Android Jelly Bean的浏览器中，checkbox.attr('checked')不会触发重绘\r\n\r\nHTML 5 time input导致Samsung Galaxy 2 ICS的Android浏览器崩溃\r\n\r\nchrome下HTML5历史错误\r\n\r\n老旧的BlackBerry将rem units视为em\r\n\r\niOS <= 6 的 Safari：当手动改变hash并移动到另一个hash后，URL栏会显示旧hash值\r\n\r\n@media screen和max-width: 320px问题\r\n\r\niOS5 日期选择器选定新日期时间后不会触发change事件\r\n\r\niOS5 文本框内的占位文本会切除过长的部分\r\n\r\n使用JS滚动页面后，iOS 5 固定位置元素重定位错误\r\n\r\n固定位置元素在BlackBerry 7虚拟器中会使浏览器崩溃\r\n\r\nAndroid浏览器无法降级使用font-family\r\n\r\nChrome Beta (Mobile) 不支持 keypress事件\r\n\r\nAndroid 4.0.(1|2) 全宽固定位置元素的回流问题\r\n\r\niOS 5的window.close问题\r\n\r\n选中菜单的Opera透明度问题\r\n\r\niOS中，使用向前或向后按钮离开时，表单的input和label元素会被加上悬停状态\r\n\r\n-webkit-overflow-scrolling:touch 不“遵守” z坐标\r\n\r\niOS: input标签不会聚焦到相应的字段\r\n\r\nAndroid -webkit-tap-highlight-color在叠加区域的高亮问题"},{"title":"类似百度页面的分享效果","content":"<!DOCTYPE html>\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\r\n    <title>类似于网站的分享效果</title>\r\n    <style type=\"text/css\">\r\n        #div1 {width:150px; height:200px;\r\n               background-color:#ff6a00;\r\n               position:absolute;\r\n               left:-150px;\r\n               top:50px;\r\n        }\r\n        #div2 {vertical-align:middle;\r\n               text-align:center;\r\n            width:20px;\r\n            height:60px;\r\n            background-color:#e64e4e;\r\n            position:absolute;\r\n            right:-20px;\r\n            top:80px;\r\n        }\r\n    </style>\r\n    <script type=\"text/javascript\">\r\n        window.onload = function () {\r\n            var div1 = document.getElementById(\"div1\");\r\n            var div2 = document.getElementById(\"div2\");\r\n\r\n            div2.onmouseover=div1.onmouseover = function () {\r\n                start(0);\r\n            };\r\n           div2.onmouseout= div1.onmouseout = function () {\r\n                start(-150);\r\n            };\r\n        };\r\n        var time = null;\r\n        function start(target) {\r\n            var speed = 0;\r\n            if (div1.offsetLeft<target) {\r\n                speed = 10;\r\n            }\r\n            if(div1.offsetLeft>target) {\r\n                speed = -10;\r\n            }\r\n            if (div1.offsetLeft == target) {\r\n                speed = 0;\r\n            }\r\n            clearInterval(time);\r\n            time = setInterval(function () {\r\n                if (div1.offsetLeft== target) {\r\n                    clearInterval(time);\r\n                }\r\n                else {\r\n                    div1.style.left = div1.offsetLeft + speed + \"px\";\r\n                }\r\n            }, 30);\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"div1\">\r\n            <div id=\"div2\">分享</div>\r\n    </div>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com<!DOCTYPE html>\r<html xmlns=\"http://www.w3.org/1999/xhtml\">\r<head>\r<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\r    <title>类似于网站的分享效果</title>\r    <style type=\"text/css\">\r        #div1 {width:150px; height:200px;\r               background-color:#ff6a00;\r               position:absolute;\r               left:-150px;\r               top:50px;\r        }\r        #div2 {vertical-align:middle;\r               text-align:center;\r            width:20px;\r            height:60px;\r            background-color:#e64e4e;\r            position:absolute;\r            right:-20px;\r            top:80px;\r        }\r    </style>\r    <script type=\"text/javascript\">\r        window.onload = function () {\r            var div1 = document.getElementById(\"div1\");\r            var div2 = document.getElementById(\"div2\");\r\r            div2.onmouseover=div1.onmouseover = function () {\r                start(0);\r            };\r           div2.onmouseout= div1.onmouseout = function () {\r                start(-150);\r            };\r        };\r        var time = null;\r        function start(target) {\r            var speed = 0;\r            if (div1.offsetLeft<target) {\r                speed = 10;\r            }\r            if(div1.offsetLeft>target) {\r                speed = -10;\r            }\r            if (div1.offsetLeft == target) {\r                speed = 0;\r            }\r            clearInterval(time);\r            time = setInterval(function () {\r                if (div1.offsetLeft== target) {\r                    clearInterval(time);\r                }\r                else {\r                    div1.style.left = div1.offsetLeft + speed + \"px\";\r                }\r            }, 30);\r        }\r    </script>\r</head>\r<body>\r    <div id=\"div1\">\r            <div id=\"div2\">分享</div>\r    </div>\r</body>\r</html>\r复制代码"},{"title":"跳动的心：transform+transition动画实例","content":"学了transition和transform，总在想到底应该做一个什么样的例子来练习这两个新的知识点，无意中看到某一位博主的笔记《纯CSS3实现一颗跳动的红心》，点进去运行了一下，感觉还不错，于是想想不如用transition和transform做一颗跳动的心，费了一番心思，终于实现了效果，算是自己第一个真正意义上的实例笔记吧。\r\n\r\nhtml+css制作思路：\r\n        1、两个div，使用transform的rotate和origin控制其翻转和翻转基点，\r\n        2、使用border-radius控制div的变形，\r\n        3、结合left等css样式拼接两个div，实现心形。\r\n\r\njs思路：\r\n        1、使用外层div的样式变化来控制内部两个div的变化（我这么做的理由是：可以避免使用js单独为两个div添加className，然后在计时器里又需要做判断等等复杂操作，不如改变外层div的类名，把内部小div的样式改变交给css来做）\r\n        2、使用setTimeout控制外层div的类名变换，然后使用定时器setInterval来设置心跳的循环。\r\n\r\n代码如下：\r<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"UTF-8\">\r\n\t<title>测试css3动画</title>\r\n\t<style type=\"text/css\">\r\n\t.box,.box2{\r\n\t\twidth: 320px;\r\n\t\theight: 272px;\r\n\t\tmargin: 50px auto;\r\n\t\tposition: relative;\r\n\t}\r\n\t.one,.two{\r\n\t\twidth: 150px;\r\n\t\theight: 250px;\r\n\t\tborder-radius: 75px 75px 0 0;\r\n\t\tbackground: red;\r\n\t\tposition: absolute;\r\n\t\tleft: 83px;\r\n\t\t-webkit-transition:500ms all;\r\n\t\t-moz-transition:500ms all;\r\n\t\t-ms-transition:500ms all;\r\n\t\ttransition:500ms all;\r\n\t}\r\n\t.one{\r\n\t\t-webkit-transform:rotate(-45deg);\r\n\t\t-moz-transform:rotate(-45deg);\r\n\t\t-ms-transform:rotate(-45deg);\r\n\t\ttransform:rotate(-45deg);\r\n\t\tleft: 50px;\r\n\t}\r\n\t.two{\r\n\t\t-webkit-transform:rotate(45deg);\r\n\t\t-moz-transform:rotate(45deg);\r\n\t\t-ms-transform:rotate(45deg);\r\n\t\ttransform:rotate(45deg);\r\n\t\tleft: 122px;\r\n\t}\r\n\t.box2 div{\r\n\t\twidth: 200px;\r\n\t\theight: 300px;\r\n\t\tborder-radius: 100px 100px 0 0;\r\n\t}\r\n\t.box2 div.one{\r\n\t\t-webkit-transform:rotate(-49deg);\r\n\t\t-moz-transform:rotate(-49deg);\r\n\t\t-ms-transform:rotate(-49deg);\r\n\t\ttransform:rotate(-49deg);\r\n\t\tleft: 19px;\r\n\t}\r\n\t.box2 div.two{\r\n\t\tleft: 112px;\r\n\t\t-webkit-transform:rotate(48deg);\r\n\t\t-moz-transform:rotate(48deg);\r\n\t\t-ms-transform:rotate(48deg);\r\n\t\ttransform:rotate(48deg);\r\n\t}\r\n\t</style>\r\n</head>\r\n<body>\r\n\t<div class=\"box\" id=\"box\">\r\n\t\t<div class=\"one\"></div>\r\n\t\t<div class=\"two\"></div>\r\n\t</div>\r\n</body>\r\n</html>\r\n<script type=\"text/javascript\">\r\n\tvar oDiv=document.getElementById(\"box\");\r\n\tvar sDiv=oDiv.getElementsByTagName(\"div\");\r\n\tvar timer=null;\r\n\tvar timer1=null;\r\n\tvar timer2=null;\r\n\r\n\ttimer=setInterval(function(){\r\n\t\taddClass();\r\n\t},1000)\r\n\tfunction addClass(){\r\n\t\tclearInterval(timer2);\r\n\t\toDiv.className=\"box2\";\r\n\t\ttimer1=setTimeout(function(){\r\n\t\t\toDiv.className=\"box\";\r\n\t\t},300);\r\n\t}\r\n</script>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n运行可以见心形跳动正常。\r\n\r\n有点小地方可能需要解释一下：\r\n        为什么使用setTimeout来控制外层的div的类名变化？\r\n        虽然没有太多的概念，但是我知道，某些事件或者是系统函数在执行之后会有一些内存上或者其他的某某滞留（大概的意思），所以最好能实现某一次事件行为执行之后能顺利消除，那么使用这样的逻辑：改变类名之前先把前面的setTimeout定时器取消，那么就能保证定时器不会滞留，不会累加，确保不会浪费浏览器资源。\r\n\r\n仅仅是一次简单的尝试，如果达人看到且愿意指点一番，感激不尽 "},{"title":"天猫前端大神js做的动画= =牛逼轰轰的样子","content":"分享给大家看看！学习！\r\nhttp://www.tmall.com/go/market/promotion-act/mv-alone.php"},{"title":"成功的程序员（转）","content":"我算是靠坑蒙拐骗进了程序员的门，然后一路狂奔。26 岁之前几乎没有任何写代码的经验，研究生毕业却意外选择了一家不可能提供培训的初创公司，在每日担忧公司倒闭、害怕被炒鱿鱼以及同事冷落白眼的三重压力下逆流而上，一年半后离职，已是拥有 500 万用户产品的后台主程。从前我对计算机技术心怀畏惧，认定技术高人一定有佛光笼罩，昼夜不息运键如飞日吐代码上万行。现在也算见过一些世面了，回首那段忐忑不安宛如初夜的过程，我却不发觉有任何的励志意味，而是视为一种理所当然。理想的程序员，和理想的建筑师、理想的财务师、理想的按摩师没有任何的差别，他们本质上都是一群手艺人。我相信理想的程序员人人皆可成为。近三年总在互联网圈厮混，我认识过一些程序员，共事过一些程序员，领导过一些程序员，又面试过一些程序员。他们学历不同，有的来自北大，有的来自北大青鸟，有的是博士，有的是高中肄业；资历也不同，有的来自 BAT，有的来自某破产基金公司（还是一个销售）；年限也从 0 到 15 年不等。但我认为程序员只需分三类：天才的程序员、理想的程序员、平庸的程序员。天才的程序员我只敢说接触过 3 个，这是天命。7 分由你是颗精子的时候就已决定，拥有绝佳的数学天赋、冷静致密的逻辑、为解决难题宁愿不眠不休而深以为乐的技术热情；3 分来自起步要早早早，恨不得同龄人玩泥巴的时候就得开始玩电脑，大学毕业前就突破一万小时法则，后面的已是游戏人生。天才的程序员可遇不可求，更不能长有，我看到的 90% 仍是平庸的程序员。IT 时代的膨胀，已让程序员如同文艺复兴时的印刷匠一样的普通，多数投入祖师爷门下的人，仅是为了更大的饭碗，更高的待遇，更好的生计。平庸的程序员编写腐烂的代码，没有规范和一致性，固守旧世界的语言，还好谈论大的架构和性能，说的比做的漂亮。而毫无例外的，他们认定技术没有出路，做产品、营销和管理的是更高大上的手艺，而他们当中的 99%，又会自然的流露出自己恰巧具备了那方面的天赋，至于进程为什么会崩溃这样的小问题是不屑于去了解的。而我最喜欢和理想的程序员相处，恨不得与他们同吃同住，如果允许，我希望我的队伍能插满他们的旗帜。理想的程序员心眼儿不坏（他们从来都不是办公室政治的宠儿，是一群单纯明亮快乐的手艺人），有天真烂漫的好奇心（他们的眼睛里经常闪着「哇，这个是怎么做到的！」），永远精益求精（他们的口头禅是「我再研究一下」），还乐于分享（他们活跃于 GitHub、各大问答社区和你的身边，舍得将宝贵时间用于帮助新手）。是的，他们不需要被管理，只需要给一个大的方向，总能回报以意想不到的结果。理想的程序员与平庸的程序员只有一墙之隔。两者的差距只有 6 个一点点，而人与人的差距，正是在这日积月累的一点点中，被永远拉开了。有意思的是，我发现这 6 个一点点都和意识有关，也就是程序员和其他一切新兴产业的工种一样，只需要意识加上时间的锤炼，人人皆可达到理想的阶段。理想的程序员必然也是一个优秀的 problem-solver。　　第 1 个一点点：专注眼下见过太多心猿意马的程序员，我不得不把「专注眼下」作为天字第一条。他们往往有各式各样的小梦想，比如做个小茶农、做个小鹅贩、做产品、做销售、做投资，却被程序员的高薪或是没有转行的魄力「耽误」了，而因为不专注，他们不在意做好自己的本分，不在意锤炼自己的技能，不在意学习新兴的技术。不可否认，这世界上存在着伟大的产品（像乔老爷）、伟大的销售（像埃里森）、伟大的投资客（像彼得菲），而他们毫无例外都是程序员出身。可你听说过巴菲特评价盖茨的话么，比尔盖茨如果转行去卖狗，那他一定是全世界最大的狗贩。我坚信除了少数的天才外，冥冥众生均可以在多个领域取得成功，只要保持足够的专注。而哪怕你下一年就想卖狗去，程序员的经验仍然能训练你强大的逻辑、谨慎和耐心，放在哪个行业都是相当可观的竞争力。　　第 2 个一点点：思考力与推动力我认为处理 bug、崩溃、调优、入侵等突发事件比编程本身更能体现平庸程序员与理想程序员的差距。当面对一个未知的问题时，如何定位复杂条件下的核心问题、如何抽丝剥茧地分析问题的潜在原因、如何排除干扰还原一个最小的可验证场景、如何抓住关键数据验证自己的猜测与实验，都是体现程序员思考力的最好场景。是的，在衡量理想程序员的标准上，思考力比经验更加重要。有时候小伙伴跑过来，问我「提交了一个任务被卡住了，怎么办」的时候，我总觉得他可以做得更好。比如，可以检查试验别的任务，以排除代码自身的原因；可以通过 Web UI 检查异常（如果没有账号，可以让我提供）；可以排查主机日志或删除缓存，再不济，总应该提供任务 ID 和控制台日志给我。理想的程序员永远不会等事情前进，他们会用尽一切方法让事情前进。　　第 3 个一点点：Never Say No记得从前厂离职之前，找老板谈话，他说我最大的优点就是从来不和他说这个做不到。后来我发现在很多团队里，都存在一种技术和产品的对立，程序员往往以「技术上无法实现」来挡产品的需求，而产品也往往以「Facebook 可以为什么我们做不到」来奚落程序员。这两句话应该属于禁语，从根本上都不利于程序猿和产品狗的相亲相爱。一句「技术上无法实现」是容易出口，可有多少人在说出这句话的时候，心里是 100% 肯定的？如果不肯定，为什么不能回去谷歌一下再回答？原本我以为程序员是充满想象力，在因为有想象力，才能诞生那么多改变我们生活的软件和互联网产品。见识多了，才了解大部分程序员已经在与 bug 的对抗中变得保守而不愿担当风险，与此同时许多团队也不愿意宽容失败。于是「Say No」变成一种习惯性的抵触，还记得曾国藩为什么解散湘军么？他说那支军队已「暮气渐深」，不能打仗了。要做理想的程序员，就不能给自己滋生暮气的机会，如果面对不合理的需求，可以把时间成本摆出来，把曲线救国方案亮出来，简单粗暴「Say No」是不可取的。　　第 4 个一点点：投资未来程序员是一个非常残忍的职业。你所学所用的语言、框架、模式，很可能在数年内就成昨日黄花了；你现在嘲笑的另一群程序员，可能马上就能转身来嘲笑你了。所以理想的程序员除了做好自己的本分，还要花费时间来投资未来。什么是「投资」？投资就是你现在投入的时间，在未来会以更多的时间或者金钱（看看早几年学习 iOS 的程序员现在的薪酬！）回报你。举我自己的领域 — 数据挖掘为例，08 年左右 Hadoop 开始兴起，一时「大数据」概念火热，Hadoop 工程师万金难求，各互联网公司纷纷把数据统计、数据分析和数据挖掘的业务切换到分布式平台上。这几年眼看 Hadoop 还在不断迭代，Spark 又异军突起，一举刷新了 Hadoop 保持的排序记录，以内存存储中间数据带来的性能优势和丰富的数据结构让人爱个不停，各种奇异的小 bug 和陡峭的学习曲线又让人打退堂鼓。那么，明眼人都知道 Spark 是未来的趋势（内存会越来越便宜），在主业务放在 Hadoop 的条件下，就可以适当把一些小模块切换到 Spark 上，同时留意 Spark 社区的发展。很快从 Spark 获得的性能收益就能把之前投入的学习时间挣回来。第 5 个一点点：善用工具善用工具可以分为 4 个层面：搜索引擎不相信重复代码片段自动化\r\n我刚入行那会，一个计算机专业却当了公务员的朋友问我，你一点都没学过编程，平时怎么写代码？我说，谷歌，于是遭到无情的耻笑，以至于我在哪里的账号都叫 2shou，告诫自己是一个无耻的二手程序员。这是一个笑话，但如果现在问我，我还是要回答谷歌。程序员的成长就像膨胀的圆饼，外面是无边无际的大海，圆饼越大，与大海接触的面也越大，懂的越多，不懂的越多，而计算机科学又是一门更新换代异常迅速的学科，同时也是知识互联网化最好的学科，很难利用传统的科班式有教有学的方法，相反通过搜索引擎则很容易获取到最新的知识。不相信重复，大师的话叫 DRY 原则（Dont repeat yourself），代码写多了，会有人为的直觉判断好的和烂的代码，我的标准是简洁和规范，简洁并不是美感上的标准，重复越少，给自己出错的机会也越少，后期维护的成本也越少。如果你不幸丢了三周前的代码，也许你能凭着过人的记忆力把脑子里残余的片段复写出来，但如果丢的是三个月前的代码，恐怕就没有那么好的运气了。理想的程序员会着力找寻有效的资料保存方式，把工作里灵光闪现写下的代码、脚本、配置、经验等短的片段保存起来，以便任何时候都能复查。理想的程序员必须懒惰。对他们来说，重复的步骤和重复的代码一样丑陋，如果意识到一项工作有可能长期要重复，那么自动化的时间总是越早越好。　第 6 个一点点：管理时间之所以管理时间会对程序员这个行当特别重要，是因为在完成任务时你必须像荒野里的狼一样，「独行」。没有外界约束的情况下还能稳定控制自己，保证能高效率地工作和学习，那么日积月累你肯定会变得比一般人厉害。程序员干的是高强度的脑力活，一般每天集中4-5 个小时应对本职工作就足够了，但工作之外，一定要安排时间用于学习。除了学习，留点时间放空自己也是必要的，利用泡茶或者喝咖啡的间隙，把弥足珍贵的时间留给自己，往前想往后想，事半功倍。说了这么多，想必有人会问，费劲心思成为一个理想的程序员，又有什么用处？会有高薪吗？不。能升职吗？也不见得。迎娶白富美呢？不如去卖狗。\r\n稻盛和夫曾经说过一个故事，明治时期的手艺人被天皇召见，虽然都是不读书的乡下人，但一辈子兢兢业业地做一件事情，自然有一股高贵的气质。理想的程序员，应该就是循着这种高贵的气质而去的吧。原文地址：http://www.techug.com/excellent-programmer"},{"title":"前端面试题整理……","content":"JavaScript：\r\n1. 介绍一下isNaN函数？\r\n \r\n如果参数不是数字类型的话isNaN返回true  （函数名称：isnan    函数功能： 判断数组的元素是否是NaN。 ）\r\n \r\n2. javascript都支持哪些布尔型的操作？\r\n \r\n&&, ||和！ （&& 逻辑与，|| 逻辑或，！逻辑非）\r\n \r\n3. “1″+2+4在javascript中得到什么？\r\n \r\n因为“1”是String类型，所以所有的操作数都是String, 结果为124\r\n \r\n4. 2+5+”8″得到的结果是什么？\r\n \r\n因为2和5是数字类型，8是字符串，所以得到的结果是78\r\n \r\n5. javascript有几种loop（循环）方法？\r\n \r\nfor, while, do-while ，for...in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。\r\n \r\n6. javascript如何创建一个新的对象？\r\n \r\nvar obj = new Object() 或者 var obj = {}\r\n \r\n7. 如何为一个对象属性赋值？\r\n \r\nobj[\"age\"]=17 或者obj.age=17\r\n \r\n8. 如何为一个数组添加一个值？\r\n \r\narr[arr.length]= value;\r\n\r\n9.javascript基本数据类型 / javascript中的typeof返回哪些数据类型\r\n\r\nNumber 类型 、Boolean 类型、Object 类型、String类型、Null、 Undefined 类型 / Object number function boolean undefined string\r\n\r\n\r\n10.例举3种强制类型转换和2种隐式类型转换?\r\n\r\n强制（parseInt,parseFloat,number）  隐式（== – ===）\r\n\r\n11.数组方法pop() push() unshift() shift()\r\n\r\n Push()尾部添加  pop()尾部删除  Unshift()头部添加  shift()头部删除\r\n\r\n12.闭包是什么，有什么特性，对页面有什么影响\r\n\r\n 闭包就是能够读取其他函数内部变量的函数。\r\n\r\n13.添加 删除 替换 插入到某个接点的方法\r\n\r\nobj.appendChild()   obj.innersetBefore()   obj.replaceChild()   obj.removeChild()\r\n\r\n14.javascript的本地对象，内置对象和宿主对象\r\n\r\n  本地对象为array obj regexp等可以new实例化\r\n  内置对象为gload Math 等不可以实例化的\r\n  宿主为浏览器自带的document,window 等\r\n\r\n15.介绍一下eval() 函数\r\n\r\neval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。\r\n\r\n16.介绍一下JSON\r\n\r\nJSON：JavaScript 对象表示法（JavaScript Object Notation）。\r\nJSON 是存储和交换文本信息的语法。类似 XML。\r\nJSON 比 XML 更小、更快，更易解析。\r\n\r\n17.jQuery UI 与 jquery 的主要区别是： 　\r\n\r\n　(1) jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 　\r\n　(2) jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等。 　\r\n　(3) jQuery本身注重于后台，没有漂亮的界面，而jQuery UI则补充了前者的不足，他提供了华丽的展示界面，使人更容易接受。既有强大的后台，又有华丽的前台。 \r\n\r\nhtml+css:\r\n1.对WEB标准以及W3C的理解与认识:\r\n\r\n    标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；\r\n\r\n2.xhtml和html有什么区别:\r\n\r\nHTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言\r\n最主要的不同：\r\nXHTML 元素必须被正确地嵌套。\r\nXHTML 元素必须被关闭。\r\n标签名必须用小写字母。\r\nXHTML 文档必须拥有根元素。\r\n\r\n3.行内元素有哪些?块级元素有哪些?CSS的盒模型?\r\n\r\n块级元素：div p h1 h2 h3 h4 form ul\r\n行内元素: a b br i span input select\r\nCss盒模型:内容，border ,margin，padding\r\n\r\n4.前端页面有哪三层构成，分别是什么?作用是什么?\r\n\r\n结构层 Html 表示层 CSS 行为层 js\r\n\r\n5.写出几种IE6 BUG的解决方法:\r\n\r\n双边距BUG float引起的 使用display3像素问题 使用float引起的 使用dislpay:inline -3px超链接hover 点击后失效 使用正确的书写顺序 link visited hover activeIe z-index问题 给父级添加position:relativePng 透明 使用js代码 改Min-height 最小高度 ！Important 解决’select 在ie6下遮盖 使用iframe嵌套为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）\r\n\r\n6.解释css sprites，如何使用。\r\n\r\nCss 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量\r\n\r\n7.你如何对网站的文件和资源进行优化?期待的解决方案包括：\r\n\r\n 文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用\r\n\r\n8.清除浮动的几种方式，各自的优缺点：\r\n\r\n使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）是用afert伪元素清除浮动(用于非IE浏览器)\r\n\r\n9.浏览器内核\r\n\r\n1、Trident内核：IE最先开发或使用的，也称IE内核，360浏览器使用的也是IE内核；\r\n2、Webkit内核：谷歌chrome浏览器最先开发或使用，也叫谷歌内核，枫树浏览器、太阳花使用的也是谷歌内核；\r\n3、Gecko内核： Netscape6开始采用的内核，后来的Mozilla FireFox (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核；\r\n4、Presto内核：目前只有Opera浏览器采用该内核\r\n\r\n"},{"title":"【译】 沙箱中的间谍 - 可行的 JavaScript 高速缓存区攻击","content":"王龑 — MAY 27, 2015 \r\n原文连接 The Spy in the Sandbox – Practical Cache Attacks in Javascript\r\n\r\n相关论文可在 https://github.com/wyvernnot/cache_attack_in_javascript 下载\r\n\r\n作者和单位\r\n\r\nYossef Oren (yos AT cs.columbia.edu)\r\nVasileios P. Kemerlis (vpk AT cs.columbia.edu)\r\nSimha Sethumadhavan (simha AT cs.columbia.edu)\r\nAngelos D. Keromytis (angelos AT cs.columbia.edu)\r\n哥伦比亚大学计算机系\r\n\r\n摘要\r\n\r\n我们将展示首个完全运行在浏览器里的针对微架构的边信道攻击手段。与这个领域里的其它研究成果不同，这一手段不需要攻击者在受害者的电脑上安装任何的 应用程序来展开攻击，受害者只需要打开一个由攻击者控制的恶意网页。这种攻击模型可伸缩性高，易行，贴近当今的网络环境，特别是由于绝大多数桌面浏览器连接到 Internet 因此几乎无法防御。这种攻击手段基于 Yarom 等人在 文[23] 提出的 LLC攻击，可以让攻击者远程获得属于其它进程、用户甚至是虚拟机的信息， 只要它们和受害者的浏览器运行在运行在同一台物理主机上。我们将阐述这种攻击背后的基本原理，然后用一种高带宽的隐藏通道验证它的效果，最后 用它打造了一个覆盖整个系统的鼠标和网络活动记录器。抵御这种攻击是可能的，但是所需的反制措施对浏览器和电脑的正常使用所产生的代价有点不实际。\r\n\r\n1 引言\r\n\r\n边信道分析是里一种非常强大的密码分析攻击。攻击者通过分析安全设备内部在进行安全运算时所产生的的物理信号（功率，辐射，热量等）来取得秘密信息[15]。 据说在二战中便有情报部门在使用，Kocher 等人在1996年首次在学术情境下讨论了这个问题[14]。边信道分析被证实可以用来侵入无数的现实世界中的系统，从汽车报警器 到高安全性的密码协处理器[8][18]。缓存攻击（Cache Attack）是和个人电脑相关的一种边信道攻击，因为高速缓冲区被不同的进程和用户使用而导致了信息的泄露[17][11]。\r\n\r\n虽然边信道攻击的能力无可置疑，但是要实际应用到系统上还是相对受限的。影响边信道攻击可行性的一个主要因素是对不确定的攻击模型的假设：除了基于网络的 时序攻击，大部分的边信道攻击都要求攻击者非常接近受害者。缓存攻击一般会假设攻击者能够在受害者的机器上执行任意的二进制的代码。虽然这个假设 适用于像 Amazon 云计算平台这样的 IaaS 或者 PaaS 环境，但是对于其它环境就不那么贴切了。\r\n\r\n在这篇报告里，我们用一种约束更少、更可行的攻击者模型挑战了这一限制性的安全假设。在我们的攻击模型里，受害者只需要访问一个网页，这个网页 由攻击者所拥有。我们会展示，即使在这么简单的攻击者模型里，攻击者依然能够在可行的时间周期里，从被攻击的系统中提取出有意义的信息。为了和这样的 计算设定保持一致，我们把注意力集中在了跟踪用户行为而不是获取密匙上。报告中的攻击方式因此是高度可行的：对于攻击者的假设和限定是 实际的；运行的时间是实际的；给攻击者带来的好处也是实际的。据我们了解，这是首个可以轻松扩展至上百万个目标的边信道攻击方式。\r\n\r\n我们假设攻击中受害者使用的个人电脑配备有较新型号的的 Intel CPU ，并进一步假设用户用支持 HTML5 的浏览器访问网页。这覆盖了绝大部分连接到 Internet 的 个人电脑，见 章节5.1 。用户被强迫访问一个页面，这个页面上有一个由攻击者控制的元素比如广告。攻击代码自己会执行基于 JavaScript 的 缓存攻击，见 章节2，持续地访问被攻击系统的 LLC 。因为所有的 CPU 内核，用户，进程，保护环等共享同一个高速缓存区，所以可为攻击者提供被攻击用户和系统的详细信息。\r\n\r\n1.1 现代 Intel CPU 的内存架构\r\n\r\n现代的计算机系统通常会采用一个高速的中央处理器（CPU）和一个容量大但是速度较慢的随机存取器（RAM）。为了克服这两个模块的性能鸿沟，现代的计算机系统会采用 高速缓存 - 一种容量小但是速度更快的内存结构，里面保存了 RAM 中最近被 CPU 访问过的子集。高速缓存通常会采用** 分层** 设计，即在CPU 和 RAM之间 分层 放置一些列逐渐变大和变慢的内存结构。图1 取自 文[22]，展示了 Intel Ivy Bridge 的缓存结构，包括：较小的 level 1(L1) cache，大一些的** level 2 (L2) cache**，最下方是最大的 level 3 (L3) cache 并和 RAM 相连。Intel 目前代号为 Haswell 的新一代 CPU 采用了另一种嵌入式的 DRAM(eDRAM) 设计，所以不在本文讨论范围内。如果 CPU 需要访问的数据当前不在缓存里，会触发一个 未命中 ，当前缓存里的一项必须被 **淘汰 **来给新元素腾出空间。\r\n\r\n图1\r\n\r\n图1：Intel Ivy Bridge\r\n\r\nIntel 的缓存微架构是 **嵌套的 **- 所有一级缓存里的数据必须同时存在二级和三级缓存里。倒过来，如果某个元素在三级缓存里被淘汰，那它也会立刻被 从二级和一级缓存里移走。需要注意的是 AMD 缓存微架构的设计是非嵌套的，所以本文描述的方法并不能立刻应用到该平台上。\r\n\r\n本文重点关注第三级缓存，通常也被称为 LLC。由于 LLC 较大，CPU 访问内存的时候如果把整个 LLC 的内容都搜索一遍效率会很低。 为了避免这个问题，LLC 通常被分成不同的 组，每一组都对应者内存空间的一个固定的子集。每个组包含若干缓存线。例如，Intel Haswell 系列中的 Core i7-3720QM 处理器拥有 8192 = 2^13 个组，每个组有 12 条 64 = 2^6 字节的缓存线，共同组成 8192 x 12 x 64 = 6 MB 的高速缓存。 CPU 如果要检查一个给定的物理地址是否在三级缓存里，会先计算出组，然后只检查组内的缓存线。结果就是，某个物理地址的缓存未命中，会导致同一个组的 为数不多的缓存线中的一条被淘汰，这个事实会被我们的攻击反复运用。由64比特长度的物理地址到13比特长度的组索引的映射方法已经被 Hund 等人在2013年 通过逆向工程得出来[12]。在表示物理地址的64个比特位里，5到0被忽略，16到6被直接用来作为组索引的低11位，63到17散列后得到组索引的高2位。 LLC 被所有的内核、线程、进程、用户，乃至运行在同一块 CPU 芯片上的虚拟机所共享，而不论特权环或其它类似的保护措施。\r\n\r\n现代的个人电脑采用了一种 虚拟内存机制，在这种机制里，用户进程一般无法直接得到或访问系统的物理内存。取而代之的是，进程会被分配不同的虚拟内存页。 如果某个虚拟内存页被当前执行的进程访问，操作系统会在物理内存里动态地分配一个页框。CPU 的内存管理单元（MMU）负责把不同进程对虚拟内存地址的访问 映射到物理内存。Intel 处理器的页和页框大小一般是4KB，并且页和页框的是按照页对齐的 - 每页的开始地址是页大小的倍数。这意味着，任何虚拟地址 的低12位和对应的虚拟地址是一一对应的，这一事实也在我们的攻击中用到。\r\n\r\n1.2 缓存攻击\r\n\r\n缓存攻击是针对微架构的攻击手段中一个典型的代表， Aciamez 在他的出色的调查中将这类攻击定义为利用 “信任架构边界下方的底层处理器结构” 从不同的安全系统中 获取秘密信息。缓存攻击基于这样的事实：尽管在上层有诸多像沙箱、虚拟内存、特权环，宿主这样的保障机制，安全和不安全进程通过高速缓存区的共用可以互相影响。 攻击者构造一个“间谍”进程后可以通过被共用的缓存来测量和干扰其它安全进程的内部状态。Hu 在1992年的首次发现[11]，在随后的一些研究成果里显示了边信道攻击可被用来获取 AES密匙[17][4]，RSA密匙[19]，甚至可以允许一台虚拟机侵入宿主上的其它机器。\r\n\r\n我们的攻击建立在 填充+探测 模型的基础上，这个方法由 Osvik 在[17]中首次描述，不过是针对一级缓存的。之后由 Yarom 等人在[23]中扩展到启用了 较大内存页系统的 LLC。我们把这个方法扩展了一下支持更加常见的 4K 的页大小。总的来说，填充+探测有四个步骤。第一步，攻击者建立一个 或多个移除集。移除集是内存中的一系列地址，这些地址被访问的时候会占据受害者进程使用的一条缓存线。第二步，攻击者通过访问移除集填充整个组。 这会强制受害者的代码或指令被从组中淘汰，并使组进入一个已知的状态。第三步，攻击者触发或只是等待受害者执行和可能使用组。最后，攻击者通过再次访问移除集来探测组。如果访问的延迟比较低，意味着攻击者的指令或数据还在缓存里。否则，较高的访问延迟意味着受害者的代码用到了组，因此攻击者可以了解受害者的内部状态。 实际的时间测量是用非特权的汇编指令RDTSC进行的，这个指令可以得到处理器非常准确的周期数。再次遍历链表还有第二个目的，那就是强制组进入 受攻击者控制的状态，为下一轮的测量做好准备。\r\n\r\n1.3 Web 运行环境\r\n\r\nJavaScript 是一种拥有动态类型，基于对象的运行时求值的脚本语言，它支撑着现代互联网的客户端。JavaScript 代码以源码的形式传到浏览器端，由浏览器 即时编译(JIT) 机制来编译和优化。不同浏览器厂商之间的激烈竞争使不断改进 JavaScript 性能备受关注。结果就是，在某些场景下，JavaScript 执行的效率已经 可以和机器语言相媲美。\r\n\r\nJavaScript 语言的核心功能是由 ECMA 产业协会在 ECMA-262 标准中定义的。语言标准由万维网协会（W3C）定义的一系 API 所补充，因此适合开发 Web 内容。 JavaScript API 的集合是不断演进的，浏览器厂商依照自己的开发计划不断增加新的 API 支持。我们的工作中用到两个具体的API: 第一个是类型数组的定义9，通过它可以高效地访问非结构化的二进制数组。 第二个是高精度时间API16，让应用程序可以进行毫秒以下时间的测量。 如 章节5.1 所示，大部分当今主流的浏览器都同时支持这两个API。\r\n\r\nJavaScript 代码运行在高度沙箱化的环境里 - 用 JavaScript 交付的代码对系统的访问非常受限。例如，JavaScript 代码如果没有用户的允许不能打开和读取文件。 JavaScript 代码不能执行机器语言或者加载本地的代码库。 最值得注意的是，JavaScript 代码没有指针的概念，所以你连一个 JavaScript 变量虚拟地址都没法知道。\r\n\r\n1.4 我们的工作\r\n\r\n我们的目的是构造一个可以通过 Web 部署的 LLC 攻击。这个过程是充满挑战的，因为 JavaScript 代码没法加载共享库或者执行本机语言的程序， 并且由于无法直接调用专用的汇编指令而被迫调用脚本语言的函数进行时间的测量。尽管有这些挑战，我们还是成功地把缓存攻击扩展到了基于 Web 环境：\r\n\r\n我们展示了一种用来在 LLC 上的建立 非典型移除集 特别方法。与[23]不同，我们的方法不要求系统配置成支持较大的内存页，所以能够很快的 应用到广泛的桌面和服务器系统。我们展示了该方法虽然是使用 JavaScript 实现的，但是依然可以在实际的时间周期里完成。\r\n我们展示了一种 功能完善的用无需特权的 JavaScript 发动 LLC 攻击 的方法。我们用隐藏通道的方式，评估了它的性能，包括在同一个机器、不同进程之间 和在虚拟机与它的主机之间。基于 JavaScript 的通道与[23]中用机器语言实现的方法类似，都可以达到每秒几百 kb 的速度。\r\n我们展示了怎么利用基于缓存的方法来有效地跟踪用户行为。缓存攻击的这一应用与我们的攻击模型更相关，这与密码分析在其它成果中的应用不同。\r\n最后，我们分析了针对攻击可能的反制措施和整个系统的代价。\r\n文档结构： 第二章，攻击方法不同阶段的设计与实现。 第三章，基于攻击方法建立起来的隐藏通道，这个通道也被用来验证方法的性能。 第四章，缓存攻击如何被用来跟踪用户在浏览器内外的行为。 第五章，总结，提出反制措施和仍未解决的研究挑战。\r\n\r\n2 攻击方法\r\n\r\n正如前文所诉，一次成功的 填充+探测 攻击包含几个步骤：为一个或多个相关组建立移除集，填充缓存，触发受害者的操作，最后再次探测组。 虽然填充和探测实现起来很简单，但是要找到对应于某个系统操作的组并且为它建立移除集就不那么容易了。在本章里，我们描述了这几个步骤用 JavaScript 如何实现。\r\n\r\n2.1 建立一个移除集\r\n\r\n2.1.1 设计\r\n\r\n正如[23]写到，填充+探测攻击方法的第一步是为某个与被攻击进程共享的组建立一个移除集。这个移除集包含一系列的变量，而且这些变量都被 CPU 映射到相同的 组里。根据 文[20] 的建议，使用链表可以避免 CPU 的内存预读和流水线优化。我们首先展示如何为任意一个组建立一个移除集，然后解决寻找与受害者共享组的问题。\r\n\r\n文[17]指出，一级缓存是依据虚拟地址的低位的比特来决定组分配的。假设攻击者知道变量的虚拟地址，那么在基于一级缓存的攻击模型里建立移除集很容易。 但是，LLC 里变量的组分配是依照物理内存的地址进行的，而且一般情况下，非特权进程无法知道。文[23]的作者为了规避这个问题，假设系统用的是 页较大的模型，在这个模型里，物理地址和虚拟地址的低21位是相同的，并通过迭代算法来获得组索引的高位。\r\n\r\n在我们所考虑的攻击模型里，系统运行在 4K 的页大小模型下，物理地址和虚拟地址只有最低的12位是相同的。然而更大的难题是，JavaScript没有指针的概念， 所以即使是自己定义的变量，虚拟地址也是不知道的。\r\n\r\n从64位物理地址到13位的组索引的映射关系已经被 Hund 等人研究过[12]。他们发现，当访问物理内存里一段连续的、8MB大小的 “淘汰缓冲区” 时会让三级缓存里的所有组 都失效。虽然我们在用户态下没有办法分配这样的一个“淘汰缓冲区” （实际上，文章[12]是通过内核模式的驱动实现的），我们用 JavaScript 在 虚拟内存里分配了一个 8MB 大小的数组（这其实是由系统分配的随机、不连续的 4K 大小物理内存页的集合），然后测量遍历这个缓冲区在全系统造成的影响。 我们发现在迭代访问了这个淘汰缓冲区后如果立即访问内存中其它不相关的变量，访问的延迟会显著的增加。 另外一个发现是，即使不访问整个缓冲区而是每隔64字节去访问它，这个现象依然存在。但是，我们所访问的 131K 个偏移值到8192个可能的组的映射关系 并没有立刻清晰起来，因为我们不知道缓冲区里各个页在物理内存中的地址。\r\n\r\n解决这个问题一个不太靠谱的做法是，给定一个任意的“受害者”在内存中的地址，通过暴力手段从 131K 个偏移值中找到12个与这个地址共享组的地址。要完成这点， 我们可以从 131K 个偏移量中选取几个作为子集，在迭代了所有的偏移量后再测量下访问的延迟有没有变化。如果延迟增加了，意味着含有12个地址的子集与 受害者地址共享相同的组。如果延迟没有变化，那子集里的12个地址中的任何一个都不在组里，这样受害者地址就还在缓存里。把这个过程重复8192遍，每次用 一个不同的受害者地址，我们就可以识别每个组并且建立自己的数据结构。\r\n\r\n受此启发而立刻写出来的程序会运行非常长的时间。幸运的是， Intel MMU 的页帧大小（章节1.1）非常有帮助，因为虚拟地址是页对齐的，每个虚拟地址的 低12位和每个物理地址的低12位是一致的。据 Hund 等人所称，12个比特中的6个被用来唯一决定组索引。因此，淘汰缓冲区中的一个偏移会和其它 8K 个偏移 共享12到6位，而不是所有 131K 个。此外，只要找到一个组就能立刻知道其它的63个在相同页帧里的组的位置。再加上 JavaScript 分配大的数据缓存区的时是 和页帧的边界对齐的，所以可以用算法1中的贪心算法。\r\n\r\n算法1 Profiling a cache set Let S be the set of unmapped pages, and address x be an arbitrary page-aligned address in memory\r\n\r\n    1. Repeat k times:\r\n    (a) Iteratively access all members of S\r\n    (b) Measure t1 , the time it takes to access x\r\n    (c) Select a random page s from S and remove it\r\n    (d) Iteratively access all members of S\\s\r\n    (e) Measure t2 , the time it takes to access x\r\n    (f) If removing page s caused the memory access to speed up          considerably (i.e., t1 − t2 > thres),\r\n    then this page is part of the same set as x. Place it back into      S.\r\n    (g) If removing page s did not cause memory access to speed up       considerably,\r\n    then this address is not part of the same set as x.\r\n    2. If |S| = 12, return S. Otherwise report failure.\r\n通过多次运行 算法1，我们可以逐渐的建立一个移除集并覆盖大部分的缓存，除了那些被 JavaScript 运行时本身所使用的。我们注意到， 与[23]中的算法建立的淘汰缓冲区不同，我们的移除集是非典型的 - 因为 JavaScript 没有指针的概念，所以如果我们发现了一个移除集 我们并没有办法知道它对应着 CPU 高速缓存的哪个组。此外，在相同的机器上每次运行这个算法都会得到不同的映射。这也许是因为用了传统的 4K 页大小 而不是 2MB 的页大小的原因，这个问题即使不用 JavaScript 用机器语言也存在。\r\n\r\n2.1.2 验证\r\n\r\n我们用 JavaScript 实现了 算法1 并且在安装了 Ivy Bridge， Sandy Bridge，Haswell 系列 CPU 的机器上进行验证，机器上装有 Safari 和 Firefox 对应运行在 Mac OS Yosemite 和 Ubuntu 14.04 LTS 操作系统上。系统并没有被配置使用大的页而是用默认的 4K 页大小。列表1 显示了实现 算法1.d 和 算法1.e 的代码，展示了 JavaScript 下怎么遍历链表和测量时间。算法如果要运行在 Chrome 和 Internet Explorer 下，需要额外的几个步骤，在 章节5.1 中。\r\n\r\n列表1\r\n\r\n     // Invalidate the cache set\r\n     var currentEntry = startAddress;\r\n    do {\r\n        currentEntry = probeView.getUint32(currentEntry);\r\n    } while (currentEntry != startAddress);\r\n    // Measure access time\r\n    var startTime = window.performance.now();\r\n    currentEntry = primeView.getUint32(variableToAccess);\r\n    var endTime = window.performance.now();\r\n\r\n图2 性能分析算法的累积表现\r\n\r\n图2显示了性能分析的结果，运行在 Intel i7-3720QM CPU 上， 装有 Firefox 35.0.1 和 Mac OS 10.10.2 。我们很高兴地发现在30秒内就 映射了超过25%的组，1分钟内就达到了50%。这个算法想要并行运行是非常简单的，因为大部分的执行时间花在了数据结构的维护上，只有一小部分花在让缓存失效和 测量上。整个算法用不到500行 JavaScript 代码就可以完成。\r\n\r\n图3\r\n图3 Haswell 上两种方法访问延迟的概率分布\r\n\r\n为了验证我们的算法能够辨别不同的组，我们设计了一个实验来比较一个变量被 flush 前后的访问延迟。图3 显示了两种方式访问变量的概率分布函数。 灰色的代表用我们的方式从缓存中 flush 出去的变量的访问时间；而黑色是驻留在缓存里的变量的访问时间。时间的测量用到 JavaScript 的高精度计时器， 所以还包括了 JavaScript 运行时的延迟。两者的不同是显而易见的。图4 显示的是在较早版本的 Sandy Bridge CPU 上捕捉到的结果，该型号每个组有16个条目。\r\n\r\n通过选取一些列的组，并且不断的测量它们的访问延迟，攻击者可以获得缓存实时活动非常详细的图。我们把这种视觉呈现称作 “内存谱图”，因为它看起来很像声音的谱图。\r\n\r\n图4\r\n图4 Sandy Bridge 上两种方法访问延迟的概率分布 \r\n图5\r\n图5 内存谱图示例 \r\n图5显示的是每隔400ms抓取一次的内存谱图。其中X轴对应时间，Y轴对应不同的组。例子中的时间分辨率是250微秒，检测了一共128个组。每个点的密度 代表了这个组在这个时间的访问延迟。黑色代表延迟较低，意味从上次测量到现在没有其它进程访问过这个组。白色意味着攻击者的数据在上次测量之后被淘汰了。\r\n\r\n细看这个内存谱图可以得到几个显而易见的事实。首先，虽然没用机器语言指令而是用了 JavaScript 的计时器，测量的抖动很小，活跃和不活跃的组 很容易被区分。图中有几条明显的垂直的线，意味着同一时间间隔里有多个相邻的组被访问。因为连续的组对应的物理内存的地址也是连续的，所以我们 相信这个信号代表着一个超过 64 字节的汇编指令。还有一些聚在一起的组被同时访问。我们推断这代表着变量的访问。最后，横着的白线预示着一个变量 被不断地访问。这个变量可能是属于测量代码的或属于当前的 JavaScript 运行时。从一个没有任何特权的网页能得到这么多信息真是太了不起了。\r\n\r\n2.2 在缓存里识别意思的区域\r\n\r\n移除集让攻击者能够监控任意一个组的活动。因为我们得到的移除集是非典型的，因此攻击者必须想办法把分析过的组和受害者的数据或是代码的地址 关联起来。这个学习/分类的问题已经由 Zhang 和 Yarom 分别在 文章[25] 和 文章[23] 里提出了，他们采用了不同的诸如 SVM 的机器学习的算法试图从 缓存延迟的测量数据里找到规律。\r\n\r\n为了有效地展开学习过程，攻击者需要诱导受害者做一些操作，然后检查哪些组被这个操作访问到，详见 算法2。\r\n\r\n    Let Si be the data structure matched to eviction set i\r\n    1. For each set i:\r\n        (a) Iteratively access all members of Si to prime the cache set\r\n        (b) Measure the time it takes to iteratively access all members of Si\r\n        (c) Perform an interesting operation\r\n        (d) Measure once more the time it takes to iteratively access all members of Si\r\n        (e) If performing the interesting operation caused the access time to slow down considerably, then the operation was\r\n        associated with cache set i.\r\n因为 JavaScript 受到一系列的权限限制，实现步骤(c)是很有挑战的。与之形成对比的是 Apecechea 等人能够用一个空的 sysenter 调用来触发一次细小的内核操作。为了实现这个步骤，我们必须调查 JavaScript 的运行时来发现有哪些函数会触发有意思的行为，例如文件访问，网络访问，内存分配等等。 我们还对那些运行时间相对较短，不会产生遗留的函数感兴趣。因为遗留可能导致垃圾回收，进而影响步骤(d)的测量。Ho 等人在 文章[10] 中已经找到了这样的 几个函数。另外一种方式是诱导用户代替攻击者执行一个特定的操作（比如在键盘上按一个键）。这个例子里的学习过程可能是结构化的（攻击者知道受害者 将要执行的时机），也可能是非结构化的（攻击者只能假设系统一段时间内的响应缓慢是由受害者的操作导致的）。这两种方法都被使用，详见 章节4。\r\n\r\n因为我们的程序会一直检测到由 JavaScript 运行时产生的活动，比如高性能的计时器的代码，浏览器其它那些与当前执行调用无关的模块的代码，实际上我们 通过调用两个相似的函数并** 对比** 它们两次活动性能分析的结果，以此来寻找相关的组。\r\n\r\n3 基于高速缓存区的隐藏信道之 JavaScript 实现\r\n\r\n3.1 动机\r\n\r\n正如 文章[23] 所示，LLC 访问模式可被用来建立一个高带宽的隐藏信道，有效的用来在同一台宿主上的两个虚拟机之间渗透敏感的信息。在我们的攻击模型里， 攻击者虽然不在同一台宿主上的虚拟机里，而是在一个网页中，隐藏信道的动机不一样，但是也很有意思。\r\n\r\n经由动机，我们假设某个安全部门在追踪犯罪大师 Bob 的踪迹。该部门通过钓鱼项目在 Bob 的个人电脑上装了一个被称作 APT( Advanced Persistent Threat ) 的 软件。APT 被设计用来记录 Bob 的犯罪记录并发送到部门的秘密服务器上。然而 Bob 非常的警觉，他使用了启用了强制信息流跟踪 （Information Flow Tracking ） [24] 的操作系统。操作系统的这一功能阻止了 APT 在访问了可能含有用户隐私数据的文件后再连上网络。\r\n\r\n在这种情况下，只要 Bob 能被诱导访问一个由安全部门控制的网页，这个部门就可以立刻采用基于 JavaScript 的高速缓存区攻击。APT 可以利用基于高速缓存区 的边信道和恶意网站通信，这样就不用通过网络传输用户的隐私数据，进而不会触发操作系统的信息流跟踪功能。\r\n\r\n这个研究案例受到了来自某个安全部门的 “RF retro-reflector” 设计的启发，在这个设计里一台诸如麦克风的收集器，并不会把接收到的信号直接发送出去， 而是把接受的信号调制到由一个外部 ”收集设备“ 发送给它的 “照射信号” 上去。\r\n\r\n3.1.1 设计\r\n\r\n隐藏信道的设计有两个需求：第一，保持发送端的简单，我们尤其不想让它执行 章节2.1 中的移除集算法。第二，因为接收端的移除集是非典型的， 它应该足够简单，这样接收端就可以搜索到发送端的信号调制到了哪一个组。\r\n\r\n为了满足这些需求，我们的发射器/ APT 在自己的内存中分配了 4K 大小的数组，并且不断地把收集到的数据转换成对与这个数组的内存访问的模式。这个 4K 大小 的数组覆盖了缓存的 64 个组，这样 APT 在每个时间周期里就能传送 64比特 的数据。为了能保证内存访问能够被接收端定位，相同的访问模式被重复 运用到数组的几个拷贝上。 因此，高速缓冲区的大部分都会被执行到，与之形成对比的是 文章[23] 中的方法使用了典型的移除集，因此只会激活两条缓存线。\r\n\r\n接收端的代码会对操作系统的内存做一个性能分析，然后搜索含有被 APT 调制后的数据所在的页框。真正的数据会被从内存访问的模式里解调出来然后传回服务器， 整个过程都不会违背操作系统对信息流跟踪的保护。\r\n\r\n3.1.2 评估\r\n\r\n我们的攻击模型假设发送端使用（相对较快的）机器语言编写，而接收端是用 JavaScript 编写。所以，我们假设整个系统性能的限制因素是恶意网站的 采样速度。\r\n\r\n为了评估隐藏信道的带宽，我们写了一个小程序用预先设定好的模式来遍历系统的内存（即含有单词\"Usenix\"的比特图）。 接下来，我们用 JavaScript 高速缓存攻击来尝试寻找这一访问模式，并测量 JavaScript 代码所能达到的最大的频率。\r\n\r\n图6\r\n图6 主机到主机的隐藏信道\r\n\r\n图6 显示的内存谱图捕捉到了这一隐藏信道的执行。隐藏信道的理论带宽通过测量大约是 320kbps，这和 文章[23] 中用机器语言实现的跨虚拟机的隐藏信道 1.2Mbps 的带宽比较吻合。\r\n\r\n图7 \r\n图7 主机到虚拟机的隐藏信道 \r\n图7 中的内存谱图比较相似，但并不是由运行在相同主机上的接收端代码得到的，而是在一台虚拟机上得到的（Firefox 34 浏览器，Ubuntu 14.01 系统， VMWare Fusion 7.1.0 ）。尽管在这个场景下的高峰频率只能到大约 8kbps，但是一个虚拟机中的网页竟然能够探测到底层的硬件，这着实让人惊讶。\r\n\r\n4 利用高速缓存区攻击跟踪用户行为\r\n\r\n绝大多数关于高速缓存区攻击的研究都假设攻击者和受害者位于云计算供应商数据中心里的同一台机器上。这样的机器一般不会配置成接收交互式的输入， 所以该领域的大部分研究都聚焦于如何获得加密钥匙或其它保密的状态信息，譬如随机数生成器的状态[26]。 本文将研究怎么利用高速缓存区攻击来跟踪用户的行为 ，这和我们的攻击模型更相关。我们注意到 文章[20] 已经尝试了利用 CPU 的一级缓存对系统负载进行细粒度的度量，以此跟踪按键事件的方法。\r\n\r\n本案例将演示一个恶意网站怎么用高速缓存区攻击去跟踪用户的活动。在接下来展示的的攻击里，我们会假设用户在一个背景标签页或窗口里打开 了一个恶意网站的页面，并且在另一个标签页或是另外一个完全没有互联网连接的应用里执行了一些敏感的操作。\r\n\r\n我们选择了把焦点集中在鼠标操作和网络活动上，因为操作系统负责处理它们的代码没有办法被忽略不计。所以，我们期待这些操作会在高速缓存区留下比较大的脚印。 而且正如下文所述，它们也很容易被 JavaScript 处处受限的安全模型所触发。\r\n\r\n4.1 设计\r\n\r\n两种攻击的结构比较类似。首先，进行性能分析，攻击者用 JavaScript 探测每一个组。接着，在训练阶段，待检测的活动（网络活动或鼠标操作）被触发， 伴随着对高速缓存区的高精度的采样。在训练阶段一方面通过测量脚本直接触发网络活动（执行一个网络请求），另一方面是不停地在网页上摇晃鼠标。\r\n\r\n通过比较在训练阶段缓存区在闲时和忙时的活动，攻击者可以知道用户操作会对应激活哪部分的组，并且训练出一个关于组的分类器。最后， 在分类阶段，攻击者不停地监视这些有意思的组从而掌握用户的活动。\r\n\r\n我们用一个基本的非结构化的训练过程，即假设训练过程中系统进行的最集中的操作就是被测量的。为了利用这点，我们计算了随着时间的 每次测量的 Hamming 权重（等于在某个周期内活跃组的个数），之后应用 k-meas 算法对测量数据做聚类。 然后计算每个簇中每个组的平均访问延迟，从而算出每个簇的中心。遇到未知的测量矢量，我们会计算这个矢量和各个中心的欧几里得距离， 并把它归到最近的那一类。\r\n\r\n在分类阶段，我们用命令行工具 wget 生成网络流量，并且将鼠标移动到窗口以外。为了获得网络活动的真实数据，我们同时用 tcp-dump 来测量系统的流量，然后把 tcp-dump 记录的时间戳和分类器所检测到时间戳联系起来。为了获得鼠标操作的真实数据，我们写了一个页面记录所有 鼠标事件及其时间戳。需要强调的是，记录鼠标活动的页面并不在运行着测量代码的浏览器（Firefox），而是运行在另一个浏览器里（Chrome）。\r\n\r\n4.2 验证\r\n\r\n图8 \r\n图8 检测到的网络活动 \r\n图9 \r\n图9 检测到的鼠标活动\r\n\r\n活动测量的结果见 图8 和 图9 。两个图片的顶端都显示了高速缓存区一个子集的实时活动。图片的底端是分类器的输出结果和外部收集的真实数据。 正如图片展示的那样，我们异常简单的分类器在识别鼠标操作和网络活动方面非常有效。毫无疑问，使用更加 高级的训练和分类技巧可以进一步提高攻击的效果。需要强调的是，鼠标操作的检测器并不会检测网络活动，反之亦然。\r\n\r\n分类器的测量频率只有　500Hz。结果就是，它没有办法统计单个的包，而只能说明在一个阶段里活跃还是不活跃。另一方面，检测鼠标活动的代码要比 记录真实数据的代码采集到的事件多。这是因为　Chrome 浏览器对鼠标事件的频率做了限制，大约是　60Hz。\r\n\r\nChen 等人在一篇著名的文章[5]中证明了对网络活动的监测可以作为深度挖掘用户行为的奠基石 。虽然 Chen 等人假设攻击者可以在网络层 监控受害者所有流入和流出的数据，但是这里所展示的技术本质上可以让恶意网站监控用户同时进行的网络操作。攻击可以被更多的指标增强， 例如内存分配（见文[13]），DOM　布局事件，磁盘写操作等。\r\n\r\n5 结论\r\n\r\n本文显示了边信道攻击的范围要比预期的大很多。本文提出的攻击可针对互联网上的大部分机器而不局限于某些特定的攻击场景。如此众多的系统突然间易受 边信道攻击意味着防止边信道攻击的算法和系统应当被广泛使用，而不能只是在某些特定情况下。\r\n\r\n5.1 易被攻击系统的普遍性\r\n\r\n我们的攻击需要一台个人计算机，并配有 Intel CPU，使用了 Sandy Bridge， Ivy Bridge， Haswell 或者 Broadwell 的微架构。据 IDC 的数据显示，2011年 以后售出的个人计算机80%都满足这一条件。更进一步，假设用户使用的浏览器支持 HTML5 高精度计时器和类型数组的规范。表1 列举了各个浏览器厂商支持这些 API 的最早的版本和易被攻击的版本占全球互联网流量的比重，统计数据来自 StatCounter GlobalStatas 2015年一月份的报告。如表所示，目前市场上 80% 的浏览器 都无法抵御此类攻击。\r\n\r\nBrowser brand"},{"title":"纯css3实现3d动画","content":"这是一个纯css3实现的3dbox动画，不含js代码，对最初接触css3 3d的朋友或许有点帮助\r\n\r<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r<head>\r        <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r        <title>Document</title>\r        <style type=\"text/css\">\r*{ margin:0px; padding: 0px}\r.wrapout{ height:1000px;width:1560px;background-color: #bbb;margin:100px 0px; border:1px solid #fff ;}\r.wrap{ width:500px;height:70%;background-color:white;margin:150px 10px;position: relative; float:left;\r        -webkit-transform-style:preserve-3d;/*显示方式为3d样式*/\r        -webkit-perspective:1500;/*设置三维透视的距离 */\r}\r.cube , .cube1{ width: 200px;height:300px;top:200px;left:150px;\r        -webkit-transform-style:preserve-3d;/*规定如何在 3D 空间中呈现被嵌套的元素*/\r        position: absolute;\r        -webkit-transform:rotateX(30deg) rotateY(30deg);/*旋转角度*/\r}\r.poster{ width:100px;height: 100px;position: absolute; top:100px;left:50px; border-radius: 10px}\r.poster1{width:200px;height: 200px;position: absolute; top:50px;left:0px; border-radius: 10px}\r\r.cube{-webkit-animation-name:ringXY;/*执行动画名称*/\r-webkit-animation-duration:3s;/*动画执行时间*/\r-webkit-animation-iteration-count:infinite;/*执行次数，这里为无数次*/\r-webkit-animation-timing-function:linear;/*执行方法为线性*/\r}\r.cube1{-webkit-animation-name:ringYX;\r-webkit-animation-duration:3s;\r-webkit-animation-iteration-count:infinite;\r-webkit-animation-timing-function:linear;\r}\r@-webkit-keyframes ringX{ /*动画自定义*/\r0%{-webkit-transform:rotateX(0deg);}\r50%{-webkit-transform:rotateX(180deg);}\r100%{-webkit-transform:rotateX(360deg);}\r}\r@-webkit-keyframes ringY{ \r0%{-webkit-transform:rotateY(0deg);}\r50%{-webkit-transform:rotateY(180deg);}\r100%{-webkit-transform:rotateY(360deg);}\r}\r@-webkit-keyframes ringYX{ \r0%{-webkit-transform:rotateY(0deg) rotateX(0deg);}\r40%{-webkit-transform:rotateY(180deg) rotateX(200deg);}\r100%{-webkit-transform:rotateY(360deg) rotateX(360deg);}\r}\r@-webkit-keyframes ringXY{ \r0%{-webkit-transform:rotateY(0deg) rotateX(0deg) ;}\r50%{-webkit-transform:rotateY(180deg) rotateX(180deg) ;}\r100%{-webkit-transform:rotateY(360deg) rotateX(360deg) ;}\r}\r        </style>\r</head>\r<body>\r<div class=\"wrapout\">\r    <div class=\"wrap\">\r            <div class=\"cube\">\r                    <div class=\"poster\" style=\"-webkit-transform:rotateX(0deg) translateZ(50px);background-color: rgba(10, 9, 9, 0.21)\"></div>\r                    <div class=\"poster\" style=\"-webkit-transform:rotateX(90deg) translateZ(50px) ;background-color:rgba(247, 0, 0, 0.41)\"></div>\r                    <div class=\"poster\" style=\"-webkit-transform:rotateX(180deg) translateZ(50px); background-color: rgba(222, 0, 247, 0.38)\"></div>\r                    <div class=\"poster\" style=\"-webkit-transform:rotateX(270deg) translateZ(50px); background-color: rgba(0, 144, 247, 0.38)\"></div>\r                    <div class=\"poster\" style=\"-webkit-transform:rotateY(90deg) translateZ(50px) ;background-color: rgba(0, 247, 125, 0.38)\"></div>\r                    <div class=\"poster\" style=\"-webkit-transform:rotateY(270deg) translateZ(50px) ;background-color: rgba(247, 244, 0, 0.42)\"></div></div>\r                   <div class=\"cube1\">\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateX(0deg) translateZ(100px) ;background-color: rgba(10, 9, 9, 0.21)\"></div>\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateX(90deg) translateZ(100px) ;background-color:rgba(247, 0, 0, 0.41)\"></div>\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateX(180deg) translateZ(100px); background-color: rgba(222, 0, 247, 0.38)\"></div>\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateX(270deg) translateZ(100px); background-color: rgba(0, 144, 247, 0.38)\"></div>\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateY(90deg) translateZ(100px) ;background-color: rgba(0, 247, 125, 0.38)\"></div>\r                    <div class=\"poster1\" style=\"-webkit-transform:rotateY(270deg) translateZ(100px) ;background-color: rgba(247, 244, 0, 0.42)\">\r            </div>\r            </div>\r\r    </div>\r</div>\r</body>\r</html>复制代码"},{"title":"JavaScript 开发的45个经典技巧","content":"JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。\r\n\r\n在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。\r\n\r\n本文中的示例代码，通过了在Google Chrome 30最新版（V8 3.20.17.15）上的测试。\r\n\r\n1、首次为变量赋值时务必使用var关键字\r\n\r\n变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。\r\n\r\n2、使用===取代==\r\n\r\n==和!=操作符会在需要的情况下自动转换数据类型。但===和!==不会，它们会同时比较值和数据类型，这也使得它们要比==和!=快。\r[10] === 10    // is false\r[10]  == 10    // is true\r'10' == 10     // is true\r'10' === 10    // is false\r []   == 0     // is true\r [] ===  0     // is false\r '' == false   // is true but true == \"a\" is false\r '' === false  // is false复制代码\n\r\n3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false\r\n\r\n4、行尾使用分号\r\n\r\n实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章JavaScript中关于分号的真相。\r\n\r\n5、使用对象构造器\rfunction Person(firstName, lastName){\r    this.firstName =  firstName;\r    this.lastName = lastName;\r}\rvar Saad = new Person(\"Saad\", \"Mousliki\");复制代码\n\r\n6、小心使用typeof、instanceof和contructor\r\n\r\ntypeof：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object\r\ncontructor：内部原型属性，可以通过代码重写\r\ninstanceof：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则返回false\rvar arr = [\"a\", \"b\", \"c\"];\rtypeof arr;   // 返回 \"object\" \rarr instanceof Array // true\rarr.constructor();  //[]复制代码\n\r\n7、使用自调用函数\r\n\r\n函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下：\r(function(){\r    // 置于此处的代码将自动执行\r})();  \r(function(a,b){\r    var result = a+b;\r    return result;\r})(10,20)复制代码\n\r\n8、从数组中随机获取成员\rvar items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];\rvar  randomItem = items[Math.floor(Math.random() * items.length)];复制代码\n\r\n9、获取指定范围内的随机数\r\n\r\n这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。\rvar x = Math.floor(Math.random() * (max - min + 1)) + min;复制代码\n\r\n10、生成从0到指定值的数字数组\rvar numbersArray = [] , max = 100;\rfor( var i=1; numbersArray.push(i++) < max;);  // numbers = [1,2,3 ... 100]复制代码\n\r\n11、生成随机的字母数字字符串\rfunction generateRandomAlphaNum(len) {\r    var rdmString = \"\";\r    for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));\r    return  rdmString.substr(0, len);\r}复制代码\n\r\n12、打乱数字数组的顺序\rvar numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];\rnumbers = numbers.sort(function(){ return Math.random() - 0.5});\r/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205]  */复制代码\n这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法），可以参见StackOverFlow上的这个讨论。\r\n\r\n13、字符串去空格\r\n\r\nJava、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为String对象函数一个trim函数：\rString.prototype.trim = function(){return this.replace(/^\\s+|\\s+$/g, \"\");};复制代码\n新的JavaScript引擎已经有了trim()的原生实现。\r\n\r\n14、数组之间追加\rvar array1 = [12 , \"foo\" , {name \"Joe\"} , -2458];\rvar array2 = [\"Doe\" , 555 , 100];\rArray.prototype.push.apply(array1, array2);\r/* array1 值为  [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */复制代码\n\r\n15、对象转换为数组\rvar argArray = Array.prototype.slice.call(arguments);复制代码\n\r\n16、验证是否是数字\rfunction isNumber(n){\r    return !isNaN(parseFloat(n)) && isFinite(n);\r}复制代码\n\r\n17、验证是否是数组\rfunction isArray(obj){\r    return Object.prototype.toString.call(obj) === '[object Array]' ;\r}复制代码\n但如果toString()方法被重写过得话，就行不通了。也可以使用下面的方法：\r\n\r\nArray.isArray(obj); // its a new Array method\r\n如果在浏览器中没有使用frame，还可以用instanceof，但如果上下文太复杂，也有可能出错。\rvar myFrame = document.createElement('iframe');\rdocument.body.appendChild(myFrame);\rvar myArray = window.frames[window.frames.length-1].Array;\rvar arr = new myArray(a,b,10); // [a,b,10]  \r// myArray 的构造器已经丢失，instanceof 的结果将不正常\r// 构造器是不能跨 frame 共享的\rarr instanceof Array; // false复制代码\n\r\n18、获取数组中的最大值和最小值\rvar  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; \rvar maxInNumbers = Math.max.apply(Math, numbers); \rvar minInNumbers = Math.min.apply(Math, numbers);复制代码\n\r\n19、清空数组\rvar myArray = [12 , 222 , 1000 ];  \rmyArray.length = 0; // myArray will be equal to [].复制代码\n\r\n20、不要直接从数组中delete或remove元素\r\n\r\n如果对数组元素直接使用delete，其实并没有删除，只是将元素置为了undefined。数组元素删除应使用splice。\r\n\r\n切忌：\rvar items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; \ritems.length; // return 11 \rdelete items[3]; // return true \ritems.length; // return 11 \r/* items 结果为 [12, 548, \"a\", undefined × 1, 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */复制代码\n\r\n而应：\rvar items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; \ritems.length; // return 11 \ritems.splice(3,1) ; \ritems.length; // return 10 \r/* items 结果为 [12, 548, \"a\", 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119]复制代码\n\r\n删除对象的属性时可以使用delete。\r\n\r\n21、使用length属性截断数组\r\n\r\n前面的例子中用length属性清空数组，同样还可用它来截断数组：\rvar myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  \rmyArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].复制代码\n\r\n与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。\rmyArray.length = 10; // the new array length is 10 \rmyArray[myArray.length - 1] ; // undefined复制代码\n\r\n22、在条件中使用逻辑与或\rvar foo = 10;  \rfoo == 10 && doSomething(); // is the same thing as if (foo == 10) doSomething(); \rfoo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething();复制代码\n\r\n逻辑或还可用来设置默认值，比如函数参数的默认值。\rfunction doSomething(arg1){ \r    arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set\r}复制代码\n\r\n23、使得map()函数方法对数据循环\rvar squares = [1,2,3,4].map(function (val) {  \r    return val * val;  \r});\r// squares will be equal to [1, 4, 9, 16] 复制代码\n\r\n24、保留指定小数位数\rvar num =2.443242342;\rnum = num.toFixed(4);  // num will be equal to 2.4432复制代码\n\r\n注意，toFixec()返回的是字符串，不是数字。\r\n\r\n25、浮点计算的问题\r0.1 + 0.2 === 0.3 // is false \r9007199254740992 + 1 // is equal to 9007199254740992\r9007199254740992 + 2 // is equal to 9007199254740994复制代码\n\r\n为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见JavaScript中的数字是如何编码的.\r\n\r\n可以通过使用toFixed()和toPrecision()来解决这个问题。\r\n\r\n26、通过for-in循环检查对象的属性\r\n\r\n下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。\rfor (var name in object) {  \r    if (object.hasOwnProperty(name)) { \r        // do something with name\r    }  \r}复制代码\n\r\n27、逗号操作符\rvar a = 0; \rvar b = ( a++, 99 ); \rconsole.log(a);  // a will be equal to 1 \rconsole.log(b);  // b is equal to 99复制代码\n\r\n28、临时存储用于计算和查询的变量\r\n\r\n在jQuery选择器中，可以临时存储整个DOM元素。\rvar navright = document.querySelector('#right'); \rvar navleft = document.querySelector('#left'); \rvar navup = document.querySelector('#up'); \rvar navdown = document.querySelector('#down');复制代码\n\r\n29、提前检查传入isFinite()的参数\risFinite(0/0) ; // false\risFinite(\"foo\"); // false\risFinite(\"10\"); // true\risFinite(10);   // true\risFinite(undefined);  // false\risFinite();   // false\risFinite(null);  // true，这点当特别注意复制代码\n\r\n30、避免在数组中使用负数做索引\r\nvar numbersArray = [1,2,3,4,5];\r\n var from = numbersArray.indexOf(\"foo\") ; // from is equal to -1\r\n numbersArray.splice(from,2); // will return [5]\r\n注意传给splice的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。\r\n\r\n31、用JSON来序列化与反序列化\rvar person = {name :'Saad', age : 26, department : {ID : 15, name : \"R&D\"} };\rvar stringFromPerson = JSON.stringify(person);\r/* stringFromPerson 结果为 \"{\"name\":\"Saad\",\"age\":26,\"department\":{\"ID\":15,\"name\":\"R&D\"}}\"   */\rvar personFromString = JSON.parse(stringFromPerson);\r/* personFromString 的值与 person 对象相同  */复制代码\n\r\n32、不要使用eval()或者函数构造器\r\n\r\neval()和函数构造器（Function consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。\rvar func1 = new Function(functionCode);\rvar func2 = eval(functionCode);复制代码\n\r\n33、避免使用with()\r\n\r\n使用with()可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。\r\n\r\n34、不要对数组使用for-in\r\n\r\n避免：\rvar sum = 0;  \rfor (var i in arrayNumbers) {  \r    sum += arrayNumbers[i];  \r}复制代码\n\r\n而是：\rvar sum = 0;  \rfor (var i = 0, len = arrayNumbers.length; i < len; i++) {  \r    sum += arrayNumbers[i];  \r}复制代码\n\r\n另外一个好处是，i和len两个变量是在for循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快：\rfor (var i = 0; i < arrayNumbers.length; i++)复制代码\n\r\n35、传给setInterval()和setTimeout()时使用函数而不是字符串\r\n\r\n如果传给setTimeout()和setInterval()一个字符串，他们将会用类似于eval方式进行转换，这肯定会要慢些，因此不要使用：\rsetInterval('doSomethingPeriodically()', 1000);  \rsetTimeout('doSomethingAfterFiveSeconds()', 5000);复制代码\n\r\n而是用：\rsetInterval(doSomethingPeriodically, 1000);  \rsetTimeout(doSomethingAfterFiveSeconds, 5000);复制代码\n\r\n36、使用switch/case代替一大叠的if/else\r\n\r\n当判断有超过两个分支的时候使用switch/case要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用switch/case了。\r\n\r\n37、在switch/case中使用数字区间\r\n\r\n其实，switch/case中的case条件，还可以这样写：\rfunction getCategory(age) {  \r    var category = \"\";  \r    switch (true) {  \r        case isNaN(age):  \r            category = \"not an age\";  \r            break;  \r        case (age >= 50):  \r            category = \"Old\";  \r            break;  \r        case (age <= 20):  \r            category = \"Baby\";  \r            break;  \r        default:  \r            category = \"Young\";  \r            break;  \r    };  \r    return category;  \r}  \rgetCategory(5);  // 将返回 \"Baby\"复制代码\n\r\n38、使用对象作为对象的原型\r\n\r\n下面这样，便可以给定对象作为参数，来创建以此为原型的新对象：\rfunction clone(object) {  \r    function OneShotConstructor(){}; \r    OneShotConstructor.prototype = object;  \r    return new OneShotConstructor(); \r} \rclone(Array).prototype ;  // []复制代码\n\r\n39、HTML字段转换函数\rfunction escapeHTML(text) {  \r    var replacements= {\"<\": \"<\", \">\": \">\",\"&\": \"&\", \"\\\"\": \"\"\"};                      \r    return text.replace(/[<>&\"]/g, function(character) {  \r        return replacements[character];  \r    }); \r}复制代码\n\r\n40、不要在循环内部使用try-catch-finally\r\n\r\ntry-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。\r\n\r\n切忌：\rvar object = ['foo', 'bar'], i;  \rfor (i = 0, len = object.length; i <len; i++) {  \r    try {  \r        // do something that throws an exception \r    }  \r    catch (e) {   \r        // handle exception  \r    } \r}复制代码\n\r\n而应该：\rvar object = ['foo', 'bar'], i;  \rtry { \r    for (i = 0, len = object.length; i <len; i++) {  \r        // do something that throws an exception \r    } \r} \rcatch (e) {   \r    // handle exception  \r}复制代码\n\r\n41、使用XMLHttpRequests时注意设置超时\r\n\r\nXMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过setTimeout()来完成这个工作：\rvar xhr = new XMLHttpRequest (); \rxhr.onreadystatechange = function () {  \r    if (this.readyState == 4) {  \r        clearTimeout(timeout);  \r        // do something with response data \r    }  \r}  \rvar timeout = setTimeout( function () {  \r    xhr.abort(); // call error callback  \r}, 60*1000 /* timeout after a minute */ ); \rxhr.open('GET', url, true);  \rxhr.send();复制代码\n\r\n同时需要注意的是，不要同时发起多个XMLHttpRequests请求。\r\n\r\n42、处理WebSocket的超时\r\n\r\n通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。\r\n\r\n为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。\rvar timerID = 0; \rfunction keepAlive() { \r    var timeout = 15000;  \r    if (webSocket.readyState == webSocket.OPEN) {  \r        webSocket.send('');  \r    }  \r    timerId = setTimeout(keepAlive, timeout);  \r}  \rfunction cancelKeepAlive() {  \r    if (timerId) {  \r        cancelTimeout(timerId);  \r    }  \r}复制代码\n\r\nkeepAlive()函数可以放在WebSocket连接的onOpen()方法的最后面，cancelKeepAlive()放在onClose()方法的最末尾。\r\n\r\n43、时间注意原始操作符比函数调用快，使用VanillaJS\r\n\r\n比如，一般不要这样：\rvar min = Math.min(a,b); \rA.push(v);复制代码\n\r\n可以这样来代替：\rvar min = a < b ? a : b; \rA[A.length] = v;复制代码\n\r\n44、开发时注意代码结构，上线前检查并压缩JavaScript代码\r\n\r\n别忘了在写代码时使用一个代码美化工具。使用JSLint(一个语法检查工具)并且在上线前压缩代码（比如使用JSMin）。注：现在代码压缩一般推荐 UglifyJS (https://github.com/mishoo/UglifyJS2)\r\n\r\n45、JavaScript博大精深，这里有些不错的学习资源\r\n\r\nCode Academy资源：http://www.codecademy.com/tracks/javascript\r\nMarjin Haverbekex编写的Eloquent JavaScript：http://eloquentjavascript.net/\r\nJohn Resig编写的Advanced JavaScript：http://ejohn.org/apps/learn/\r\n\r\n\r\n\r\n补充：\r\n\r\n\r\n首先强调犀牛书很牛逼,到底有多牛逼呢,很多面试笔试的问题,其实犀牛书中都有涉及,部分问题有详解.俺很无聊的把知识测试部分给扣下来了(2章到14章),有需要的同学可以看看啦,手打难免出错,大家多多纠正.鞠躬!\r\nchapter2\r\n1.在下列的变量名中,哪些是合法的变量名?哪些是非法变量名?为什么\r\n$someVariable\r\n_someVariable\r\n1Variable\r\nsome_Variable\r\nfunction \r\nsome*variable\r\n----答案----\r\n合法:\r\n$someVariable\r\n_someVariable\r\nsome_Variable\r\n非法:\r\n1Variable 首字母是非法字母\r\nfunction  保留字\r\nsome*variable  包含非法字符*\r\n\r\n2.将下列标示符转为骆驼拼写法\r\nvar some_month;\r\nfunction theMonth  //返回当前月份的函数\r\ncurrent-month  //常量\r\nvar summer_month;//夏季月份的数组\r\nMyLibrary-afunction//javascript包中的某个函数\r\n----答案----\r\nvar someMonth;\r\nfunction getCurrentMonth \r\nCURRENT_MONTH \r\nsummerMonths\r\nmyLibraryFunction\r\n\r\n3.下列字符串是否合法？如果不合法，如何修改？\r\nvar someString='who once said,\"only two things are infinite,the universe\r\nand human stupidity,and I'm not sure about the former.\"'\r\n----答案----\r\n字符串非法，修改方法为在双引号中只是用单引号或者转义双引号\r\n\r\nvar someString=\"who once said,'only two things are infinite,the universe\r\nand human stupidity,and I'm not sure about the former.'\"\r\n\r\nvar someString='who once said,\"only two things are infinite,the universe\r\nand human stupidity,and I\\'m not sure about the former.\"'\r\n\r\n4.对于给定的数字432.54，用什么javascript函数可以返回该数字的整数部分？如何\r\n转换为八进制和十进制？\r\n----答案----\r\nvar fltNumber=432.54;\r\nvar intNumber=parseInt(fltNumber);\r\nvar octNumber=intNumber.toString(8);\r\nvar hexNumber=intNumber.toString(16);\r\n\r\n5.在JavaScript程序库中创建一个新的JavaScript函数，该函数包含一个名为someMonth\r\n的参数，如何判断该参数是否为null或者undefined变量？\r\n----答案----\r\n使用以下代码测试变量是否赋值（非空并且已经定义）\r\nif(a){...}\r\n然而如果从来没有声明过该值，该测试会导致一个错误，因为确实向该函数传递了不存在的变量。\r\n为避免这种错误的方式而应该把该值传递给函数之前测试该值，使用下面的代码：\r\nif(typeof(a)!=\"undefined\"){...}\r\n结合测试null的代码，可以测试一个变量是否存在，是否已经定义，是否实际上有一个非空的null值\r\nif((typeof(a)!=\"undefined\")&&a){...}\r\n===========================================================\r\n\r\nchapter3\r\n1.请为下列的表达式添加圆括号，从而使得表达式的结果为8\r\nvar valA=37;\r\nvar valB=3;\r\nvar valC=18;\r\nvar resultOfComp=varA-varB%3/2*4+varC-3;\r\n----答案----\r\nvar resultOfComp=(varA-varB)%3/2*(4+varC)-3;\r\n\r\n2.请使用switch语句，判断表达式的数值是否为'one','two'或者'three',当表达式为'one'或者'two'\r\n的时候将变量的值设置为'OK';当表达式的值为'three'的时候，将变量值设置为'OK2';如果没有匹配的\r\n值，就将变量的值设置为'NONE'。\r\n----答案----\r\nswitch(val){\r\ncase'one':\r\ncase'two':\r\n        result='OK';\r\n        break;\r\ncase'three':\r\n        result='OK2';\r\n        break;\r\ndefault:\r\n        result='NONE';\r\n}\r\n\r\n3.假设有3个变量，varOne,varTwo,varThree。那么如何对这三个变量进行判断，从而仅当\r\nvarOne为33，varTwo小于等于100,但是varThree大于0的时候执行某段代码？\r\n----答案----\r\nif((varOne==33)&&(varTwo<=100)&&(varThree>0))\r\n\r\n4.如果希望执行某段代码6次，有哪3种方式？对这3种方式如何取舍？\r\n----答案----\r\nfor(var i=0;i<6;i++){...}\r\n\r\ni=0;\r\nwhile(i<6){... i++;}\r\n\r\ni=0;\r\ndo{i++;...}while(i<6)\r\ndo...while适合不论条件是否成立都至少要执行一次代码块的情况。\r\nfor循环适合代码块需要执行特定的次数的情况。\r\nwhile循适合代码块会影响条件表达式的判断的情况。\r\n\r\n5.下列条件表达式是否有问题？如果有，那么是什么问题？\r\nif(valTest1==valTest2)...\r\n----答案----\r\n如果不确定变量的数据类型，那么请考虑使用严格相等运算符\r\n===========================================================\r\n\r\nchapter4\r\n1.以逗号分隔的字符串是常见的数据格式。如何根据逗号分隔的字符串创建数组呢？\r\n请以下面的字符串创建一个数组，并访问第三个元素：\r\n\"cats,dogs,birds,horses\"\r\n----答案----\r\n使用String.split方法，传入逗号作为分隔符，如\r\nvar animalString=\"cats,dogs,birds,horses\";\r\nvar animalArray=String.split(animalString,\",\");\r\nalert(animalArray[2]);\r\n\r\n2.特殊字符\\b是表示分隔单词的符号，而\\B则是表示非分割单词符号。请定义一个正则表达式，\r\n在下面的字符串中查找所有单词fun，并将其替换成power。\r\n\"The fun of function is that they are functional.\"\r\n----答案----\r\nvar funPattern=/\\bfun\\b/;\r\nvar strToSearch=\"The fun of function is that they are functional.\";\r\nvar afterMatch=strToSearch.replace(funPattern,\"power\");\r\n\r\n3.编写一段代码，获取今天的日期并计算下一周同一天的日期。\r\n----答案----\r\nvar dtNow=new Date();\r\nvar hours=dtNow.getHours();\r\nhours+=168;//7*24\r\ndtNow.setHours(hours);\r\ndocument.writeln(dtNow.toString());\r\n\r\n4.编写一段代码，分别对数字34.44执行向上和向下取整操作。\r\n----答案----\r\nvar baseNum=34.44;\r\nvar numFloor=Math.floor(baseNum);//Math.floor可以对数字执行向下取整\r\nvar numCeil=Math.ceil(baseNum);//Math.ceil可以对数字执行向上取整\r\n\r\n5.根据下面的字符串，利用模式匹配将已有的标点符号替换成逗号，然后作为数组载入，\r\n并输出每个数值:\r\nvar str=\"apple.orange-strawberry,lemon-.lime\";\r\n----答案----\r\nvar strToAlter=\"apple.orange-strawberry,lemon-.lime\";\r\nvar puncPattern=/[\\.|-]/g;\r\nvar afterMatch=strToAlter.replace(puncPattern,\",\");\r\nvar fruits=afterMatch.split(',');\r\nfor(var i=0;i<fruits.length;i++){\r\n        document.writeln(fruits);\r\n        }\r\n===========================================================\r\n\r\nchapter5\r\n1.对一个数字(n)执行阶乘操作，将得到1~n的数字乘积，通常写做3!(1*2*3或者6)。\r\n或者编写一个javascript函数，使用递归的方法计算出指定数字的阶乘。\r\n----答案----\r\nfunction findFactorial(n){\r\nif(n==0)return 1;\r\nreturn (n*findFactorial(n-1));\r\n}\r\nvar num=findFactorial(4);//将返回24\r\n\r\n2.函数如何才能修改其作用域之外的变量？编写一个函数，由1~5的数字组成的数组作为\r\n参数，调用该函数后把其中的数字项替换成相应的字符串表示形式(也就是\"one\",\"two\"等)\r\n----答案----\r\n如果将一个对象(如一个数组)作为函数的参数传入，那么在函数中对这个数组的修改就会\r\n反映到函数外部。针对这个问题，其中一种解决办法是：\r\nfunction makeArray(){\r\nvar arr=[1,5,3];\r\nalert(arr);\r\nalterArray(arr);\r\nalert(arr);\r\n}\r\n\r\nfunction alterArray(arrofNumbers){\r\nfor(var i=0;i<arrofNumbers.length;i++){\r\n   switch(arrofNumbers){\r\n        case 1:arrofNumbers=\"one\";break;\r\n        case 2:arrofNumbers=\"two\";break;\r\n        case 3:arrofNumbers=\"three\";break;\r\n        case 4:arrofNumbers=\"four\";break;\r\n        case 5:arrofNumbers=\"five\";break;\r\n}}}\r\n\r\n3.创建一个函数，它的参数是一个数据对象和一个函数，它将对这个数据对象调用该函数。\r\n----答案----\r\n使用匿名函数满足需求\r\nfunction invokeFunction(dataObject,functionToCall){\r\nfunctionToCall(dataObject);\r\n}\r\nvar funcCall=new Function('x','alert(x)');\r\ninvokeFunction('hello',funcCall);\r\n===========================================================\r\n\r\nchapter6\r\n1.编写一段代码，用来测试某个变量的值，不得使用特定于浏览器的调试器。\r\n----答案----\r\n要测试一个变量的值最快的方法是使用警告窗口\r\n//测试一些变量\r\nalert(firstname);//其值要么已设置，要么为null，要么为undefined\r\n\r\n2.css属性text-shadow的历史很有趣，它曾经被添加到CSS2标准中，但没有浏览器实现它，\r\n然后再CSS2.1标准中又被删掉了。不过，然后浏览器实现了它，现在它已经添加到了CSS3\r\n标准中，目前4个目标浏览器中已经有3个实现了该属性。是否可以通过对象检测来测试浏\r\n览器是否支持这个样式属性？编写一段跨浏览器兼容的代码，对一个已有的header元素设\r\n置这个CSS属性\r\n----答案----\r\n首先想到的方法可能是测试是否在style对象中实现了textShadow，这是针对该CSS属性\r\n启用脚本的名称，但其和opacity/alpha示例一样，这不是始终可以依赖的办法。\r\n最简单的方法是直接设置textShadow的值，不管浏览器是否支持，如果浏览器支持它，\r\n则会改变该元素的textShadow值；如果浏览器不支持，那么仍然会动态设置该值并且忽略它：\r\nvar headerElement=document.getElementById(\"pageHeader\");\r\nheaderElement.style.textShadow=\"#ff0000 2px 2px 3px\";\r\n===========================================================\r\n\r\nchapter7\r\n1.编写一段代码，使用DOM Level 0方法为document的click事件指定一个事件处理函数。\r\n----答案----\r\ndocument.onclick=clickMe;\r\n\r\n2.现在，使用DOM Level 2事件处理机制为document添加click事件处理程序(不用考虑跨浏览器兼容问题)。\r\n----答案----\r\ndocument.addEventListener(\"click\",clickMe,false);\r\n\r\n3.如何使问题2中所写的代码能够安全的运行在所有浏览器上？\r\n----答案----\r\nif(document.addEventListener){\r\n        document.addEventListener(\"click\",clickMe,false);\r\n}else if(document.attachEvent){\r\n        document.attachEvent(\"onclick\",clickMe);\r\n}\r\n\r\n4.对于为document对象指定的onclick事件处理程序，如何知道是在屏幕的什么位置执行了单击操作？\r\n----答案----\r\n如果使用DOM Level 0的事件处理系统，那么要么访问window对象的event对象，要么将其作为\r\n参数传递给函数。对于DOM Level 2事件处理模型而言，event对象始终会传递给事件处理函数。\r\n可以通过event对象访问其screenX和screenY属性。\r\n\r\n5.使用DOM Level 2事件系统，如何组织从其他元素中冒泡上来的事件？\r\n----答案----\r\nIE支持的方法和绝大多数浏览器支持的方法不太一样，因此需要分别支持IE和其他浏览器，\r\n可以检查event对象是否支持stopPropagation方法，如果支持，则调用它，否则就将cancelBubble\r\n属性设置为true.\r\n\r\n6.将下面这段针对DOM Level 0的事件处理程序改为能够跨浏览器兼容的DOM Level 2方法：\r\n<body onload=\"functionCall();\">\r\n----答案----\r\nif(window.addEventListner){\r\n        window.addEventListener(\"load\",functioncall,false);\r\n}else if(window.attachEvent){\r\n        window.attachEvent(\"onload\",functioncall);\r\n}\r\n\r\n7.编写一段JavaScript程序代码，捕获document对象的keydown事件，然后通过调用\r\ndocument.writeln函数输出当前所按的键。\r\n----答案----\r\n虽然没有介绍过键盘捕捉事件，但在此处捕获的是keydown事件；然后从该事件的\r\nwhich属性中就能够获取当前的unicode格式的键码\r\nwindow.onload=function(){\r\n        if(document.addEventListener){\r\n          document.addEventListener(\"keydown\",getKey,false);\r\n        }else if(document.attachEvent){\r\n          document.attachEvent(\"keydown\",getKey);\r\n        }\r\n}\r\nfunction getKey(event){\r\n  var  theEvent=event?evnt:window.event;\r\n  document.writeln(theEvent.which);\r\n}\r\n\r\n===========================================================\r\n\r\nchapter8\r\n1.如果表单数据不完整或者无效，如何停止表单提交操作？\r\n----答案----\r\n如果使用DOM Level 0的事件，那么只要从事件处理程序中返回false值，并且事件处理脚本\r\n取消对表单的提交操作即可。如果使用DOM Level 2的事件，那么就将event对象的cancelBubble\r\n属性设置为true(针对IE)，并调用其preventDefault方法(针对其他浏览器)。\r\n\r\n2.想在表单提交之前对文本框的内容进行验证，那么应该捕获它的什么事件？\r\n----答案----\r\n当一个字段失去焦点时将触发blur事件，这时是检查文本框的值并确保其为有效数据的最佳时机。\r\n\r\n3.如果要确保一个字段的内容只包含字符和空格，应该使用什么样的代码？\r\n----答案----\r\nvar fieldPattern=/^[A-Za-z\\s]*$/g;\r\nvar OK=fieldPattern.exec(document.form[0].text1.value);\r\n\r\n4.编写一段JavaScript代码当选中一个单选按钮时捕获触发事件，如果单击其中一个按钮，\r\n则禁用文本框；如果单击另一个按钮，则启用文本框。\r\n----答案----\r\n首先，代码必须为每个单选按钮的onclick事件处理程序指定一个事件处理函数：\r\ndocument.forms[0].radiogroup[0].onclick=handleClick;\r\ndocument.forms[0].radiogroup[1].onclick=handleClick;\r\n如果有多个按钮，那么通过一个for循环实现该过程更加简单。在handleClick函数中，检查单选\r\n按钮是否选中，并根据其结果决定是否禁用该表单元素。例如，禁用submit按钮：\r\nfunction  handleClick(){\r\nif(document.forms[0].radiogroup[1].checked){\r\n        document.forms[0].submit.disabled=true;\r\n}else{\r\n        document.forms[0].submit.disabled=false;\r\n}\r\n}\r\n===========================================================\r\n\r\nchapter9\r\n1.如果希望得到一个文本响应，那么应该使用哪种对话框？在程序代码中使用这个对话框，让用户\r\n输入其姓氏。\r\n----答案----\r\n如果希望获得一个文本响应应该使用prompt对话框，\r\nvar firstname=prompt(\"enter your first name\",\"\");\r\n\r\n2.定义一个定时器，使其隔3000毫秒调用一个callFunction函数，并且传入两个参数：paramA和paramB。\r\n----答案----\r\nsetTimeout(callFunction,3000,paramA,paramB);\r\n\r\n3.如果要检查cookie是否启用，应该使用什么样的程序代码？\r\n----答案----\r\n可以通过navigator对象来检查cookie是否启用：\r\nif(navigator.cookieEnabled)...\r\n\r\n4.创建一个大小为200px*200px的，不带工具栏和状态栏的新窗口，并在该窗口中打开Google的搜索页面。\r\n----答案----\r\nvar newWindow=\r\nwindow.open(\"http://www.google.com\",\"\",\"width=200,height=200,toolbar=no,status=no\");\r\n\r\n5.访问web页面的表单元素有哪些方法？\r\n----答案----\r\n如果这个表单元素有标识符，可以使用document.getElementById方法，还可以\r\n通过document对象的forms集合来访问表单元素。\r\n===========================================================\r\n\r\nchapter10\r\n1.说出几种在客户端计算机上存储信息的方法。\r\n----答案----\r\n将日期或者其他信息存储到客户端计算机上有以下的几种办法：\r\n使用cookie；使用第三方插件，如flash或Google Gears；\r\n要求用户在一个链接的资源上单击鼠标右键，然后将其保存到本地计算机上；\r\n插入一个作为链接的可下载文件；\r\n创建一个用来保存数据的浏览器扩展；\r\n使用HTML5.0中的localStorage。\r\n\r\n2.脚本的cookie由几个部分组成？\r\n----答案----\r\n脚本的cookie是由cookie名称，值，日期，与cookie相关联的路径组成的。\r\n\r\n3.如何创建在浏览器关闭时自动删除的cookie？\r\n----答案----\r\n不提供任何有效日期，并且/或者将值设置为空。\r\n\r\n4.对于用户输入的哪类数据需要进行清理？\r\n----答案----\r\n任何可以在浏览器上调用的数据，或者能够用来监听客户端cookie的，或者能够\r\n运行服务器端进程的，在用户输入过程中都将进行清理。特别是\"javascript:\"\r\n或脚本标签都会从输入中清理。但对输入清理并不完全是直接删除。对于管理工具而言，\r\n用户在一个特定的帖子或者页面中输入脚本是可行的。但在一个多用户环境中，某个用户\r\n就可能通过脚本获得使用该系统的其他用户信息。\r\n\r\n5.考虑你已经创建或未来将创建的网站。请构思脚本cookie在你网站中可能实现的5个不同用途。\r\n那么在这些应用场景中，你需要的空间是否比cookie所能提供的更大？\r\n----答案----\r\n维护某个人的名字，URL和评论系统的电子邮件；\r\n为数据项提供实时反馈；\r\n启用拼写检查；\r\n保存登陆信息；\r\n维护购物车；\r\n以上这些数据所需的存储空间不超过4KB。\r\n===========================================================\r\n\r\nchapter11\r\n1.所有HTML元素都支持的属性有哪些？\r\n----答案----\r\n这样的属性包括id,title,lang,dir,className\r\n\r\n2.当给定一个已命名的元素时，如何使用HTML DOM找到其元素类型？\r\n----答案----\r\n访问该元素的tagName属性。\r\n\r\n3.给定一个位于核心DOM中的节点，如何输出其每个子节点的元素类型？\r\n----答案----\r\nvar children=targetNode.childNodes;\r\nfor(var i=0;i<children.length;i++){\r\n        alert(children.nodeType);\r\n}\r\n\r\n4.已知页面中的所有div元素，如何找出这些div元素的ID（标识符）？\r\n----答案----\r\nvar divs=document.getElementByTagName('div');\r\nfor(var i=0;i<divs.length;i++){\r\nalert(divs.id);\r\n}\r\n\r\n5.对于下面这个元素，如果要访问它有哪三种不同类型的方法？\r\n<div id=\"elem1\" class=\"thediv\">...</div>\r\n----答案----\r\nvar theDiv=docuemnt.getElementById(\"elem1\");\r\n\r\nvar theDivs=document.getElementByTagName(\"div\")；\r\nvar theDiv=theDivs[0];\r\n\r\n\r\nvar theDivs=document.getElementByClassName(\"thediv\")；\r\nvar theDiv=theDivs[0];\r\n\r\n6.除了使用innerHTML，如何将下面这个div元素中的header元素换成一个段落：\r\n<div id=\"elem1\">\r\n<h1>this is a header</h1>\r\n</div>\r\n----答案----\r\nvar targetElement=document.getElementById('elem1');\r\nvar specChild=targetElement.getElementByTagName('h1')[0];\r\nvar newPara=document.createElement('p');\r\nvar paraTxt=document.createTextNode('hello');\r\nnewPara.appendChild(paraTxt);\r\n\r\ntargetElement.replaceChild(newPara,specChild);\r\n===========================================================\r\n\r\nchapter12\r\n1.当在JavaScript程序中尝试使用obj.style.color方法访问一个元素的文本颜色时，却没有任何返回值。\r\n你知道这个字体颜色是通过样式表设置的。为什么没有任何返回值？要如何修改程序才能够获取该值？\r\n写一段代码，访问名为“name”的元素的字体颜色，以演示你的方法。\r\n----答案----\r\n可以使用getComputedStyle方法或currentStyle方法，这取决于使用的是哪种浏览器。另外一种方法是在\r\n页面载入时设置style属性。\r\nvar nameDiv=document.getElementById(\"name\");\r\nvar nameColor;\r\nif(nameDiv.currentStyle){\r\nnameColor=nameDiv.currentStyle['color'];        \r\n}else if(window.getComputedStyle){\r\nnameColor=\r\ndocument.defaultView.getComputedStyle(nameDiv,null).getPropotypeVaule('color');\r\n}\r\n\r\n2.对于div中的文本，如何将其显示的样式改成14px的字体，红色，行高16px？\r\n----答案----\r\ndivElement.style.font=\"14px/16px\";\r\ndivElement.style.color=\"#ff0000\";\r\n\r\n3.如果之前的修改未生效，可能是什么原因导致的？\r\n----答案----\r\n如果这个div元素中的文本实际上是属于另一个元素的，如一个段落元素，并且它有不同的样式设置，\r\n那么段落元素的样式设置将覆盖外层的div元素的新样式设置。\r\n\r\n4.让一个HTML元素块消失有哪三种办法？写一段代码，将名为“name”的元素彻底从页面布局中删除掉，\r\n以演示方法。\r\n----答案----\r\n要让一个div元素消失，可以将其width或height属性设置为0，或者将整个元素完全修剪掉。还可以将\r\n该元素的visibility属性设置为hidden，或者将其display属性设置为none。最后还可以将该元素移到\r\n页面外，移动到最顶部或者最左边。如果要从页面布局中删除该元素，需要修改display属性：\r\nvar nameDiv=document.getElementById(\"name\");\r\nname.style.display=\"none\";\r\n\r\n5.如果拖放技术不是有效的购物车技术，那么对于这种类型的服务，可以使用哪种动态web页面效果？\r\n----答案----\r\n除了使用拖放功能，还可以为显示\"Buy me!\"信息的链接或图像添加一个鼠标单击事件处理程序，当\r\n触发这个单击事件处理程序时，在应用程序中添加一些代码，以便自动将所选商品添加到购物车中。\r\n===========================================================\r\n\r\nchapter13\r\n1.如果要为Number对象创建一个名为triple的新办法，用来求当前Number对象的数值的3倍，而且希望\r\n该方法能够适用于所有数字，那么要怎么实现呢？\r\n----答案----\r\n使用Number的prototype属性：\r\nNumber.prototype.triple=function(){\r\n  var nmToTriple=this.valueOf()*3;\r\n  return nmToTriple;\r\n}\r\nvar newNum=new Number(3.0)；\r\nalert(newNum.triple());\r\n\r\n2.如何隐藏新对象的数据成员？为什么要这样做？\r\n----答案----\r\n通过var关键字声明数据成员，而不是把数据成员赋予this。数据隐藏的目的是控制如何访问或者修改数据。\r\n\r\n3.创建一个参数为数字类型的函数，并且当参数类型错误时返回错误。如果不使用return语句，应该\r\n实现该功能？\r\n----答案----\r\n使用throw语句触发错误，然后在主调程序中通过try...catch语句捕捉异常。\r\nif(typeof value !=\"number\"){\r\n        throw \"NotANumber\";\r\n}\r\n\r\n4.在之前的事例中可以用于事件的对象检测代码\r\nvar theEvent=nsEvent?nsEvent:window.event;\r\n为什么在处理透明度差异的时候不能使用相同的功能呢？\r\n----答案----\r\n与event对象不一样，处理透明度的时候不只会涉及到业务模型上的差异。不仅属性不同，而且与\r\n赋值属性的可能值有关。\r\n\r\n5.创建一个自定义对象，使其拥有3个公有办法，changeState,getColor和getState;以及两个私有\r\n数据成员:background和state。将state属性设置为on，将background颜色属性设置为#fff。\r\nchangeState方法同时用来判断state是否为on，如果state为on，那么将state改为off，并同时将\r\n颜色设置为#000。getColor方法将返回背景颜色，getState负责返回状态。\r\n----答案----\r\nfunction Control(){\r\n  var state='on';\r\n  var background='#fff';\r\n  \r\n  this.changeState=function(){\r\n        if(state=='on'){\r\n          state='off';\r\n          background='#000';\r\n        }else {\r\n          state='on';\r\n          background='#fff';\r\n        }\r\n  };\r\n  this.getState=function(){\r\n     return state;\r\n  };\r\n  this.getColor=function(){\r\n     return background;\r\n  };\r\n}\r\n===========================================================\r\n\r\nchapter14\r\n1.XMLHttpRequest请求也可以设置为同步模式（也就是停下来等待响应），虽然这看起来和Ajax\r\n的概念有些背道而驰。但应该如何打开这样的请求呢？\r\n----答案----\r\nXMLHttpRequest.open函数的第三个，可选的参数是一个布尔值。将该参数设置为true(默认值)\r\n将创建异步请求；如果将其设置为false则将创建同步请求。\r\n\r\n2.当请求接受到响应时，就需要对响应进行处理。那么如何指定在服务器响应时调用的函数呢？\r\n----答案----\r\n当获得XMLHttpRequest对象的引用并调用其open方法之后，将赋值给onReadyStateChange属性。\r\n\r\n3.对于Ajax请求而言，表示请求成功需要对哪两个状态进行判断？表示请求完成呢？\r\n----答案----\r\nXMLHttpRequest对象的readyState属性值为4就表示请求完成，要表明服务请求是成功的，\r\n还必须确保其status属性值为200。\r\n===========================================================\r\n\r\n转自：http://www.w3cfuns.com/blog-5455438-5404397.html\r\n"},{"title":"这些年，我收集的JavaScript代码","content":"一、取URL中的参数\r\n\rfunction getParameterByName(name) {\r    var match = RegExp('[?&]' + name + '=([^&]*)')\r                    .exec(window.location.search);\r    return match && decodeURIComponent(match[1].replace(/\\+/g, ' '));\r}复制代码\n二、正则分组\r\n\rvar testStr=\"<div><img src='/a.jpg' alt='' /><span>test</span><img src='/b.jpg' alt='' /><span>TTest</span><img src='/c.png' alt='' /></div>\";\rvar reg=/<img\\ssrc='(.*?)'\\s+alt=''\\s*\\/>/g;\rvar match=reg.exec(testStr),results=[];\rwhile(match != null){\r    results.push(match[1]);\r    match=reg.exec(testStr);\r}\rconsole.log(results);\r/*\rArray [\"/a.jpg\", \"/b.jpg\", \"/c.png\"]\r*/复制代码\n三、为什么parseInt(1/0,19)的结果为18\r\n\r\n　　1/0的结果是Infinity，所以parseInt(1/0,19)等同于parseInt(\"Infinity\",19)，而在19进制中：\r\n\r\n 19进制       10进制\r\n--------------------\r\n   0            0\r\n   1            1\r\n   2            2\r\n   3            3\r\n   4            4\r\n   5            5\r\n   6            6\r\n   7            7\r\n   8            8\r\n   9            9\r\n   a            10\r\n   b            11\r\n   c            12\r\n   d            13\r\n   e            14\r\n   f             15\r\n   g            16\r\n   h            17\r\n   i             18\r\n　　i表示18，所以parseInt(1/0,19)的结果为18。\r\n\r\n四、jQuery中获取设置checkbox选中状态\r\n\r\n　　由于在jQuery1.6以后.attr(\"checked\")的返回结果是 checked，所以一般用下面两种方法获取选中状态：\r\n\r$(\"#checkboxID\").is(\":checked\");\r\r//jQuery 1.6 +\r$(\"#checkboxID\").prop(\"checked\");\r　　选中checkbox：\r\r//jQuery 1.6+\r$(\"#checkboxID\").prop(\"checked\", true);\r$(\"#checkboxID\").prop(\"checked\", false);\r\r//jQuery 1.5 and below\r$('#checkboxID').attr('checked','checked')\r$('#checkboxID').removeAttr('checked')复制代码\n五、jQuery中判断一个元素是否存在\r\n\rif ($(selector).length)复制代码\n六、用JavaScript对URL进行编码\r\n\rvar myUrl = \"http://example.com/index.html?param=1&anotherParam=2\";\rvar myOtherUrl = \"http://example.com/index.html?url=\" + encodeURIComponent(myUrl);复制代码\n七、jQuery中event.preventDefault() 与 return false 的区别\r\n\r//Demo1 event.preventDefault()\r$('a').click(function (e) {\r    // custom handling here\r\r    e.preventDefault();\r});\r\r//Demo2 return false\r$('a').click(function () {\r    // custom handling here\r\r    return false;\r};\r　　jQuery中return false相当于同时调用e.preventDefault 和 e.stopPropagation。复制代码\n\r\n　　要注意的是，在原生js中，return false仅仅相当于调用了e.preventDefault。\r\n\r\n八、JavaScript检查一个字符串是否为空最简单的方法\r\n\rif (strValue) {\r    //do something\r}复制代码\n九、用JavaScript添加和删除class\r\n\r//Add Class\rdocument.getElementById(\"MyElement\").className += \" MyClass\";\r\r//Remove Class\rdocument.getElementById(\"MyElement\").className = document.getElementById(\"MyElement\").className.replace(/(?:^|\\s)MyClass(?!\\S)/,'');复制代码\n十、在jQuery中取消一个ajax请求\r\n\rvar xhr = $.ajax({\r    type: \"POST\",\r    url: \"test.php\",\r    data: \"name=test\",\r    success: function(msg){\r       alert( msg );\r    }\r});\r\r//取消请求\rxhr.abort()复制代码\n　　要注意的是，在ajax请求未响应之前可以用xhr.abort()取消，但如果请求已经到达了服务器端，这样做的结果仅仅是让浏览器不再监听这个请求的响应，但服务器端仍然会进行处理。\r\n\r\n十一、JavaScript删除数组中的项 delete vs splice\r\n\rvar myArray=[\"a\",\"b\",\"c\"];\rdelete myArray[0];\rfor(var i=0,j=myArray.length;i<j;i++){\r    console.log(myArray[i]);\r    /*\r    undefined\r    b\r    c\r    */\r}\r\rvar myArray2=[\"a\",\"b\",\"c\"];\rmyArray2.splice(0,1);\rfor(var i=0,j=myArray2.length;i<j;i++){\r    console.log(myArray2[i]);\r    /*\r    b\r    c\r    */\r}复制代码\n　　上面的代码已经说明区别了，一个是设置为undefined，一个是真正的删除了。\r\n\r\n十二、JavaScript中16进制与10进制相互转换\r\n\rvar sHex=(255).toString(16);//ff\rvar iNum=parseInt(\"ff\",16);//255复制代码\n十三、JavaScript多行字符串\r\n\r\n　　如何在JavaScript中方便地写一个多行字符串呢，有三种方案，你自己选吧：\r\n\r//one\rvar testHtml=\"a\"+\r\"b\"+\r\"c\";\r\r//two\rvar testHtml2=\"a\\\rb\\\rc\";\r\r//three\rvar testHtml3=[\"a\",\r\"b\",\r\"c\"].join(\"\");复制代码\n十四、JavaScript中!!操作符是什么\r\n\rconsole.log(!!10);//true\rconsole.log(!!0);//false\rconsole.log(!!\"abc\");//true\rconsole.log(!!\"\");//false复制代码\n　　简单地说就是把右侧的值转为bool值\r\n\r\n十五、JavaScript实现endsWith\r\n\rString.prototype.endsWith = function(suffix) {\r    return this.indexOf(suffix, this.length - suffix.length) !== -1;\r};\r\r//or\rfunction endsWith(str, suffix) {\r    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r}复制代码\n十六、JavaScript中克隆对象\r\n\rfunction clone(obj) {\r    // Handle the 3 simple types, and null or undefined\r    if (null == obj || \"object\" != typeof obj) return obj;\r\r    // Handle Date\r    if (obj instanceof Date) {\r        var copy = new Date();\r        copy.setTime(obj.getTime());\r        return copy;\r    }\r\r    // Handle Array\r    if (obj instanceof Array) {\r        var copy = [];\r        for (var i = 0, var len = obj.length; i < len; ++i) {\r            copy[i] = clone(obj[i]);\r        }\r        return copy;\r    }\r\r    // Handle Object\r    if (obj instanceof Object) {\r        var copy = {};\r        for (var attr in obj) {\r            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\r        }\r        return copy;\r    }\r\r    throw new Error(\"Unable to copy obj! Its type isn't supported.\");\r}复制代码\n十七、JavaScript字符与ASCII码间的转换\r\n\rconsole.log(\"\\n\".charCodeAt(0));//10\rconsole.log(String.fromCharCode(65));//A复制代码\n十八、JavaScript中浮点数的相等判断不能用 ==\r\n\rconsole.log(0.1+0.2 == 0.3);//false\rconsole.log(Math.abs(0.1+0.2 - 0.3) < 0.000001);//true复制代码\n　　如上所示，浮点数相等判断要用差的绝对值小于某一个数来判断。至于原因可以参考这里：http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\r\n\r\n十九、JavaScript中base64编码\r\n\rvar Base64 = {\r\r// private property\r_keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\r\r// public method for encoding\rencode : function (input) {\r    var output = \"\";\r    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r    var i = 0;\r\r    input = Base64._utf8_encode(input);\r\r    while (i < input.length) {\r\r        chr1 = input.charCodeAt(i++);\r        chr2 = input.charCodeAt(i++);\r        chr3 = input.charCodeAt(i++);\r\r        enc1 = chr1 >> 2;\r        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r        enc4 = chr3 & 63;\r\r        if (isNaN(chr2)) {\r            enc3 = enc4 = 64;\r        } else if (isNaN(chr3)) {\r            enc4 = 64;\r        }\r\r        output = output +\r        this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\r        this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\r\r    }\r\r    return output;\r},\r\r// public method for decoding\rdecode : function (input) {\r    var output = \"\";\r    var chr1, chr2, chr3;\r    var enc1, enc2, enc3, enc4;\r    var i = 0;\r\r    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\r\r    while (i < input.length) {\r\r        enc1 = this._keyStr.indexOf(input.charAt(i++));\r        enc2 = this._keyStr.indexOf(input.charAt(i++));\r        enc3 = this._keyStr.indexOf(input.charAt(i++));\r        enc4 = this._keyStr.indexOf(input.charAt(i++));\r\r        chr1 = (enc1 << 2) | (enc2 >> 4);\r        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r        chr3 = ((enc3 & 3) << 6) | enc4;\r\r        output = output + String.fromCharCode(chr1);\r\r        if (enc3 != 64) {\r            output = output + String.fromCharCode(chr2);\r        }\r        if (enc4 != 64) {\r            output = output + String.fromCharCode(chr3);\r        }\r\r    }\r\r    output = Base64._utf8_decode(output);\r\r    return output;\r\r},\r\r// private method for UTF-8 encoding\r_utf8_encode : function (string) {\r    string = string.replace(/\\r\\n/g,\"\\n\");\r    var utftext = \"\";\r\r    for (var n = 0; n < string.length; n++) {\r\r        var c = string.charCodeAt(n);\r\r        if (c < 128) {\r            utftext += String.fromCharCode(c);\r        }\r        else if((c > 127) && (c < 2048)) {\r            utftext += String.fromCharCode((c >> 6) | 192);\r            utftext += String.fromCharCode((c & 63) | 128);\r        }\r        else {\r            utftext += String.fromCharCode((c >> 12) | 224);\r            utftext += String.fromCharCode(((c >> 6) & 63) | 128);\r            utftext += String.fromCharCode((c & 63) | 128);\r        }\r\r    }\r\r    return utftext;\r},\r\r// private method for UTF-8 decoding\r_utf8_decode : function (utftext) {\r    var string = \"\";\r    var i = 0;\r    var c = c1 = c2 = 0;\r\r    while ( i < utftext.length ) {\r\r        c = utftext.charCodeAt(i);\r\r        if (c < 128) {\r            string += String.fromCharCode(c);\r            i++;\r        }\r        else if((c > 191) && (c < 224)) {\r            c2 = utftext.charCodeAt(i+1);\r            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\r            i += 2;\r        }\r        else {\r            c2 = utftext.charCodeAt(i+1);\r            c3 = utftext.charCodeAt(i+2);\r            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r            i += 3;\r        }\r\r    }\r\r    return string;\r}\r}\r\r//encode\rBase64.encode(\"Test\"); //VGVzdA==\r\r//decode\rBase64.decode(\"VGVzdA==\"); // Test复制代码\n二十、jQuery中each跟map的区别\r\n　　each跟map都可以用来遍历Array或Object，区别是each不改变原来的Array或Object，map是操作给定的Array或Object返回一个新Array或Object。Demo:\r\n\rvar items = [1,2,3,4];\r\r$.each(items, function() {\r  alert('this is ' + this);//alert 1,2,3,4\r});\r\rvar newItems = $.map(items, function(i) {\r  return i + 1;\r});\r// newItems is [2,3,4,5]复制代码\n　　map会占用更多的内存，所以如果只是遍历建议用each。\r\n\r\n二十一、判断一个对象是否为数组\r\n\rfunction isArray(obj){\r    return Object.prototype.toString.call(obj) == \"[object Array]\";\r}复制代码\n　　不能用instanceof 和 constructor来判断，原因参考：http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\r\n\r\n二十二、通过原型继承创建一个新对象\r\n\rfunction inherit(p){\r    if(!p){\r        throw TypeError(\"p is not an object or null\");\r    }\r    if(Object.create){\r        return Object.create(p);\r    }\r    var t=typeof p;\r    if(t !== \"object\" && t !== \"function\"){\r        throw TypeError(\"p is not an object or null\");\r    }\r    function f(){};\r    f.prototype=p;\r    return new f();\r}复制代码\n注意：这种方法不能处理参数为null的情况。\r\n原文来自：http://www.cnblogs.com/jscode/archive/2012/07/25/2605395.html"},{"title":"HTML5 CANVAS随机点线视觉3D效果","content":"这几天工作比较清闲，学习canvas，制作了一个点线连接的有点3D效果的东东\r\n演示地址：猛击吧！\r\n\r$(function(){\r            var canvasBg = new PointLine('#canvas', 15, parseInt($(window).height()), parseInt($(window).width()));\r            canvasBg.lineColor = 'red';\r            canvasBg.drawLine().drawPoint(15).reDraw(100, 50)//.mouseMove();\r        });复制代码\n\r<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title>html5-canvas制作动态点线背景</title>\r\n    <link rel=\"stylesheet\" href=\"http://yui.yahooapis.com/3.18.1/build/cssnormalize/cssnormalize-min.css\">\r\n    <script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"></script>\r\n    \r\n    <style>\r\n        canvas{\r\n            background: #000;\r\n            display:block;\r\n        }\r\n    </style>\r\n    <script>\r\n        $(function(){\r\n            var canvasBg = new PointLine('#canvas', 15, parseInt($(window).height()), parseInt($(window).width()));\r\n            canvasBg.lineColor = 'red';\r\n            canvasBg.drawLine().drawPoint(15).reDraw(100, 50)//.mouseMove();\r\n        });\r\n\t\t\r\n\t\t//PointLine object\r\n        function PointLine(ele, num, height, width){\r\n            this.ele = $(ele);\r\n            this.num = num ? parseInt(num) : 10;\r\n            this.radius = 3;\r\n            this.height = height ? parseInt(height) : 800;\r\n            this.width = width ? parseInt(width) : 600;\r\n            this.pointColor = '#fff';\r\n            this.lineColor = '#fff';\r\n            this.pointArr = [];\r\n            //point Array\r\n            var ele = this.ele, num = this.num,  height = this.height, width =this.width;\r\n            ele.get(0).height = height;\r\n            ele.get(0).width = width;\r\n            for(var i=0; i<num; i++){\r\n                var px = Math.floor(Math.random() * (width - 1) + 1), py = Math.floor(Math.random() * (height - 1) + 1);\r\n                (function(){\r\n                    for(var j in this.pointArr){\r\n                        if(px == this.pointArr[j][0]){\r\n                            px = Math.floor(Math.random() * (width - 1) + 1);\r\n                        }else{\r\n                            return px;\r\n                        }\r\n                    }\r\n                }());\r\n                this.pointArr.push([px, py]);\r\n            }\r\n        }\r\n        PointLine.prototype = {\r\n            drawPoint : function(){\r\n                var ele = this.ele, eleGet = ele.get(0), radius = this.radius, height = this.height, pointColor = this.pointColor, arr = this.pointArr;\r\n                //radius value\r\n                if(arguments.length >= 1){\r\n                    radius = !isNaN(parseInt(arguments[0])) ? parseInt(arguments[0]) : radius;\r\n                    this.radius = radius;\r\n                }\r\n                //3D Array\r\n                var leftArr = [], rightArr = [];\r\n                for(var i in arr){\r\n                    if(arr[i][0] <= height/2){\r\n                        leftArr.push(arr[i]);\r\n                    }else{\r\n                        rightArr.push(arr[i]);\r\n                    }\r\n                }\r\n                //draw point\r\n                if(eleGet.getContext){\r\n                    var leftRadius = 0, rightRadius = 0;\r\n                    for(var i in leftArr){\r\n                        drawAnim(leftArr[i], leftRadius);\r\n                        leftRadius += radius/leftArr.length/1.2;\r\n                    }\r\n                    for(var i in rightArr){\r\n                        drawAnim(rightArr[i], rightRadius);\r\n                        rightRadius += radius/rightArr.length/1.2;\r\n                    }\r\n                }\r\n                function drawAnim(arr, sub){\r\n                    var point = eleGet.getContext('2d');\r\n                    point.fillStyle = pointColor;\r\n                    point.beginPath();\r\n                    point.arc(arr[0], arr[1], (radius - sub), 0, 2*Math.PI, false);\r\n                    point.fill();\r\n                }\r\n                return this;\r\n            },\r\n            drawLine : function(){\r\n                var eleGet = this.ele.get(0), lineColor = this.lineColor, arr = this.pointArr;\r\n                if(eleGet.getContext){\r\n                    var line = eleGet.getContext('2d');\r\n                    line.strokeStyle = lineColor;\r\n                    line.beginPath();\r\n                    for(var i=0; i<arr.length; i++){\r\n                        for(var j=1; j<arr.length - i; j++){\r\n                            line.moveTo(arr[i][0], arr[i][1]);\r\n                            line.lineTo(arr[i+j][0], arr[i+j][1]);\r\n                        }\r\n                    }\r\n                    line.stroke();\r\n                }\r\n                return this;\r\n            },\r\n\t\t\treDraw : function(scope, speed){\r\n\t\t\t\tif(!isNaN(scope) && !isNaN(speed)){\r\n\t\t\t\t\tvar _this = this, eleGet = this.ele.get(0), arr = this.pointArr, newArr = arr.slice(0), aArr = [], bArr = [], step = 0;\r\n\t\t\t\t\tvar redraw = eleGet.getContext('2d');\r\n\t\t\t\t\t//变化数组\r\n\t\t\t\t\tfor(var i=-scope; i<=scope; i++){\r\n                        aArr.push(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t\taArr = aArr.concat(aArr.slice(0).reverse());\r\n                    for(var i=scope; i>=-scope; i--){\r\n                        bArr.push(i);\r\n                    }\r\n                    bArr = bArr.concat(bArr.slice(0).reverse());\r\n\t\t\t\t\tfor(var i=0; i<aArr.length; i++){\r\n\t\t\t\t\t    if(aArr[i + 1] == aArr[i]){\r\n\t\t\t\t\t\t    aArr.splice(i, 2, aArr[i]);\r\n\t\t\t\t\t\t}\r\n                        if(bArr[i + 1] == bArr[i]){\r\n                            bArr.splice(i, 2, bArr[i]);\r\n                        }\r\n\t\t\t\t\t};\r\n\t\t\t\t\taArr.splice(aArr.length - 1, 1);\r\n                    bArr.splice(bArr.length - 1, 1);\r\n\t\t\t\t\t//定时器\r\n\t\t\t\t    setInterval(function(){loop()}, speed);\r\n\t\t\t\t\tfunction loop(){\r\n                        redraw.clearRect(0, 0, _this.width, _this.height);\r\n\t\t\t\t\t\tif(step < aArr.length - 1){\r\n\t\t\t\t\t\t\tstep ++;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tstep = 0;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvar na = aArr[step], nb = bArr[step];\r\n\t\t\t\t\t\tfor(var i=0; i<arr.length; i++){\r\n\t\t\t\t\t\t    if(i % 2 == 0){\r\n\t\t\t\t\t\t\t    arr.splice(i, 1, [newArr[i][0] + nb, newArr[i][1] + na]);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    arr.splice(i, 1, [newArr[i][0] + na, newArr[i][1] + nb]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_this.drawLine().drawPoint(_this.radius);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n            mouseMove : function(){\r\n                var _this = this, ele = this.ele, eleGet = ele.get(0), height = this.height, width = this.width, arr = this.pointArr;\r\n\t\t\t\tvar redraw = eleGet.getContext('2d');\r\n                ele.hover(function(ev){\r\n\t\t\t\t\tvar mx = ev.originalEvent.x || ev.originalEvent.layerX || 0, my = ev.originalEvent.y || ev.originalEvent.layerY || 0;\r\n                    ele.mousemove(function(e){\t\t\t\t\t\t\r\n                        redraw.clearRect(0, 0, width, height);\r\n\t\t\t\t\t\tvar mxl = e.originalEvent.x || e.originalEvent.layerX || 0, myl = e.originalEvent.y || e.originalEvent.layerY || 0;\r\n                        for(var i in arr){\r\n                            arr.splice(i, 1, [arr[i][0] + mxl - mx, arr[i][1] + myl - my]);\r\n                        }\r\n                        _this.drawLine().drawPoint(_this.radius);\r\n\t\t\t\t\t\tmx = mxl;\r\n\t\t\t\t\t\tmy = myl;\r\n                    });\r\n                }, function(){\r\n\t\t\t\t\tele.off('mousemove');\r\n\t\t\t\t});\r\n                return this;\r\n            }\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n<canvas class=\"canvas\" id=\"canvas\">您的浏览器不支持HTML5元素，请升级您的浏览器！</canvas>\r\n<div id=\"arr\"></div>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com"},{"title":"JavaScript学习（二）DOM节点","content":"<!DOCTYPE>\r<html>\r  <head>节点</head>\r <body>\r  <ul>\r    <li name=\"one\">第一个li节点</li>\r     <li name=\"two\">第二个li节点</li>\r</ul>\r<script type=\"text/JavaScript\">\r var attribute=document.getElementsByTagName(\"li\");\r for(var i=0;i<attribute.length;i++)\r{\r        document.write(attribute[i].getAttribute(\"name\"));\r}\r</script>\r</body>\r</html>复制代码\n(1)getElementsByName和getElementsByTagName返回的是一个数组，所以对它进行循环操作时，要注明是第几个attribute.\r\n(2)子节点childNodes包括元素节点，文本节点等。刚接触时要理解它们是分割的,不要误理解为就是几个元素节点！ \r\n(3)字节点可以表示为nodeName.childNodes.lastChild也可以表示为nodeName.lastChild."},{"title":"做一个好的程序猿","content":"我算是靠坑蒙拐骗进了程序员的门，然后一路狂奔。26 岁之前几乎没有任何写代码的经验，研究生毕业却意外选择了一家不可能提供培训的初创公司，在每日担忧公司倒闭、害怕被炒鱿鱼以及同事冷落白眼的三重压力下逆流而上，一年半后离职，已是拥有 500 万用户产品的后台主程。从前我对计算机技术心怀畏惧，认定技术高人一定有佛光笼罩，昼夜不息运键如飞日吐代码上万行。现在也算见过一些世面了，回首那段忐忑不安宛如初夜的过程，我却不发觉有任何的励志意味，而是视为一种理所当然。理想的程序员，和理想的建筑师、理想的财务师、理想的按摩师没有任何的差别，他们本质上都是一群手艺人。我相信理想的程序员人人皆可成为。\r\n\r\n近三年总在互联网圈厮混，我认识过一些程序员，共事过一些程序员，领导过一些程序员，又面试过一些程序员。他们学历不同，有的来自北大，有的来自北大青鸟，有的是博士，有的是高中肄业；资历也不同，有的来自 BAT，有的来自某破产基金公司（还是一个销售）；年限也从 0 到 15 年不等。但我认为程序员只需分三类：天才的程序员、理想的程序员、平庸的程序员。天才的程序员我只敢说接触过 3 个，这是天命。7 分由你是颗精子的时候就已决定，拥有绝佳的数学天赋、冷静致密的逻辑、为解决难题宁愿不眠不休而深以为乐的技术热情；3 分来自起步要早早早，恨不得同龄人玩泥巴的时候就得开始玩电脑，大学毕业前就突破一万小时法则，后面的已是游戏人生。\r\n\r\n天才的程序员可遇不可求，更不能长有，我看到的 90% 仍是平庸的程序员。IT 时代的膨胀，已让程序员如同文艺复兴时的印刷匠一样的普通，多数投入祖师爷门下的人，仅是为了更大的饭碗，更高的待遇，更好的生计。平庸的程序员编写腐烂的代码，没有规范和一致性，固守旧世界的语言，还好谈论大的架构和性能，说的比做的漂亮。而毫无例外的，他们认定技术没有出路，做产品、营销和管理的是更高大上的手艺，而他们当中的 99%，又会自然的流露出自己恰巧具备了那方面的天赋，至于进程为什么会崩溃这样的小问题是不屑于去了解的。\r\n\r\n而我最喜欢和理想的程序员相处，恨不得与他们同吃同住，如果允许，我希望我的队伍能插满他们的旗帜。理想的程序员心眼儿不坏（他们从来都不是办公室政治的宠儿，是一群单纯明亮快乐的手艺人），有天真烂漫的好奇心（他们的眼睛里经常闪着「哇，这个是怎么做到的！」），永远精益求精（他们的口头禅是「我再研究一下」），还乐于分享（他们活跃于 GitHub、各大问答社区和你的身边，舍得将宝贵时间用于帮助新手）。是的，他们不需要被管理，只需要给一个大的方向，总能回报以意想不到的结果。\r\n\r\n理想的程序员与平庸的程序员只有一墙之隔。两者的差距只有 6 个一点点，而人与人的差距，正是在这日积月累的一点点中，被永远拉开了。有意思的是，我发现这 6 个一点点都和意识有关，也就是程序员和其他一切新兴产业的工种一样，只需要意识加上时间的锤炼，人人皆可达到理想的阶段。理想的程序员必然也是一个优秀的 problem-solver。\r\n　　第 1 个一点点：专注眼下\r\n见过太多心猿意马的程序员，我不得不把「专注眼下」作为天字第一条。他们往往有各式各样的小梦想，比如做个小茶农、做个小鹅贩、做产品、做销售、做投资，却被程序员的高薪或是没有转行的魄力「耽误」了，而因为不专注，他们不在意做好自己的本分，不在意锤炼自己的技能，不在意学习新兴的技术。不可否认，这世界上存在着伟大的产品（像乔老爷）、伟大的销售（像埃里森）、伟大的投资客（像彼得菲），而他们毫无例外都是程序员出身。可你听说过巴菲特评价盖茨的话么，比尔盖茨如果转行去卖狗，那他一定是全世界最大的狗贩。我坚信除了少数的天才外，冥冥众生均可以在多个领域取得成功，只要保持足够的专注。而哪怕你下一年就想卖狗去，程序员的经验仍然能训练你强大的逻辑、谨慎和耐心，放在哪个行业都是相当可观的竞争力。\r\n　　第 2 个一点点：思考力与推动力\r\n我认为处理 bug、崩溃、调优、入侵等突发事件比编程本身更能体现平庸程序员与理想程序员的差距。当面对一个未知的问题时，如何定位复杂条件下的核心问题、如何抽丝剥茧地分析问题的潜在原因、如何排除干扰还原一个最小的可验证场景、如何抓住关键数据验证自己的猜测与实验，都是体现程序员思考力的最好场景。是的，在衡量理想程序员的标准上，思考力比经验更加重要。\r\n\r\n有时候小伙伴跑过来，问我「提交了一个任务被卡住了，怎么办」的时候，我总觉得他可以做得更好。比如，可以检查试验别的任务，以排除代码自身的原因；可以通过 Web UI 检查异常（如果没有账号，可以让我提供）；可以排查主机日志或删除缓存，再不济，总应该提供任务 ID 和控制台日志给我。理想的程序员永远不会等事情前进，他们会用尽一切方法让事情前进。\r\n　　第 3 个一点点：Never Say No\r\n记得从前厂离职之前，找老板谈话，他说我最大的优点就是从来不和他说这个做不到。后来我发现在很多团队里，都存在一种技术和产品的对立，程序员往往以「技术上无法实现」来挡产品的需求，而产品也往往以「Facebook 可以为什么我们做不到」来奚落程序员。这两句话应该属于禁语，从根本上都不利于程序猿和产品狗的相亲相爱。\r\n\r\n一句「技术上无法实现」是容易出口，可有多少人在说出这句话的时候，心里是 100% 肯定的？如果不肯定，为什么不能回去谷歌一下再回答？原本我以为程序员是充满想象力，在因为有想象力，才能诞生那么多改变我们生活的软件和互联网产品。见识多了，才了解大部分程序员已经在与 bug 的对抗中变得保守而不愿担当风险，与此同时许多团队也不愿意宽容失败。于是「Say No」变成一种习惯性的抵触，还记得曾国藩为什么解散湘军么？他说那支军队已「暮气渐深」，不能打仗了。要做理想的程序员，就不能给自己滋生暮气的机会，如果面对不合理的需求，可以把时间成本摆出来，把曲线救国方案亮出来，简单粗暴「Say No」是不可取的。\r\n　　第 4 个一点点：投资未来\r\n程序员是一个非常残忍的职业。你所学所用的语言、框架、模式，很可能在数年内就成昨日黄花了；你现在嘲笑的另一群程序员，可能马上就能转身来嘲笑你了。所以理想的程序员除了做好自己的本分，还要花费时间来投资未来。什么是「投资」？投资就是你现在投入的时间，在未来会以更多的时间或者金钱（看看早几年学习 iOS 的程序员现在的薪酬！）回报你。举我自己的领域 — 数据挖掘为例，08 年左右 Hadoop 开始兴起，一时「大数据」概念火热，Hadoop 工程师万金难求，各互联网公司纷纷把数据统计、数据分析和数据挖掘的业务切换到分布式平台上。这几年眼看 Hadoop 还在不断迭代，Spark 又异军突起，一举刷新了 Hadoop 保持的排序记录，以内存存储中间数据带来的性能优势和丰富的数据结构让人爱个不停，各种奇异的小 bug 和陡峭的学习曲线又让人打退堂鼓。那么，明眼人都知道 Spark 是未来的趋势（内存会越来越便宜），在主业务放在 Hadoop 的条件下，就可以适当把一些小模块切换到 Spark 上，同时留意 Spark 社区的发展。很快从 Spark 获得的性能收益就能把之前投入的学习时间挣回来。\r\n第 5 个一点点：善用工具\r\n善用工具可以分为 4 个层面：\r\n•搜索引擎\r\n•不相信重复\r\n•代码片段\r\n•自动化\r\n\r\n\r\n我刚入行那会，一个计算机专业却当了公务员的朋友问我，你一点都没学过编程，平时怎么写代码？我说，谷歌，于是遭到无情的耻笑，以至于我在哪里的账号都叫 2shou，告诫自己是一个无耻的二手程序员。这是一个笑话，但如果现在问我，我还是要回答谷歌。程序员的成长就像膨胀的圆饼，外面是无边无际的大海，圆饼越大，与大海接触的面也越大，懂的越多，不懂的越多，而计算机科学又是一门更新换代异常迅速的学科，同时也是知识互联网化最好的学科，很难利用传统的科班式有教有学的方法，相反通过搜索引擎则很容易获取到最新的知识。\r\n\r\n不相信重复，大师的话叫 DRY 原则（Dont repeat yourself），代码写多了，会有人为的直觉判断好的和烂的代码，我的标准是简洁和规范，简洁并不是美感上的标准，重复越少，给自己出错的机会也越少，后期维护的成本也越少。\r\n\r\n如果你不幸丢了三周前的代码，也许你能凭着过人的记忆力把脑子里残余的片段复写出来，但如果丢的是三个月前的代码，恐怕就没有那么好的运气了。理想的程序员会着力找寻有效的资料保存方式，把工作里灵光闪现写下的代码、脚本、配置、经验等短的片段保存起来，以便任何时候都能复查。\r\n\r\n理想的程序员必须懒惰。对他们来说，重复的步骤和重复的代码一样丑陋，如果意识到一项工作有可能长期要重复，那么自动化的时间总是越早越好。\r\n　第 6 个一点点：管理时间\r\n之所以管理时间会对程序员这个行当特别重要，是因为在完成任务时你必须像荒野里的狼一样，「独行」。没有外界约束的情况下还能稳定控制自己，保证能高效率地工作和学习，那么日积月累你肯定会变得比一般人厉害。\r\n\r\n程序员干的是高强度的脑力活，一般每天集中4-5 个小时应对本职工作就足够了，但工作之外，一定要安排时间用于学习。除了学习，留点时间放空自己也是必要的，利用泡茶或者喝咖啡的间隙，把弥足珍贵的时间留给自己，往前想往后想，事半功倍。\r\n\r\n说了这么多，想必有人会问，费劲心思成为一个理想的程序员，又有什么用处？会有高薪吗？不。能升职吗？也不见得。迎娶白富美呢？不如去卖狗。\r\n 稻盛和夫曾经说过一个故事，明治时期的手艺人被天皇召见，虽然都是不读书的乡下人，但一辈子兢兢业业地做一件事情，自然有一股高贵的气质。理想的程序员，应该就是循着这种高贵的气质而去的吧。\r\n"},{"title":"水果机里+new Date(\"2015-05-27 13:44:00\");取时间戳返回NaN","content":"刚好有个同事问到，说在PC端，跟安卓机里，用+new Date(\"2015-05-27 13:44:00\");都可以返回时间戳，唯独在水果机（ios）里，不管是UC浏览器，自带浏览器，还是微信，都是返回NaN,后来想起PC端里系统时间显示的格式是“/”,立马将其替之，duang~,时间戳取到了。"},{"title":"记下移动端开发界面的那些事儿--输入框获取焦点，页面放大解决方法","content":"今天搞一个移动端的登录界面，画草图、做原型，一切OK，开始编码^_^\r\n\r\n各种乱乱完成之后，尝试着编写小可的第一个移动端登录界面……\r\n\r\n忙活了那么个一些歌时间后，算是结束了界面的编写，奈何在移动端做测试的时候发现一个BUG妹纸来找我的茬……\r\n\r\nIs---输入框获取焦点之后呢，页面整体放大，实属不符合小可的意愿啊！\r\n\r\n找资料，翻大牛博客……才得知，原来当输入框获取焦点之后触发了webview的displaySoftKeyboard方法，导致页面放大；具体的解决方案可以在头部加入下面的代码：\r <meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\r <meta name=\"viewport\" content=\"width=device-width,height=device-height,inital-scale=1.0,maximum-scale=1.0,user-scalable=no;\">复制代码\n\r\n在头部的<head>中增加第一句话，其中【apple-mobile-web-app-capable】设置Web应用是否以全屏模式运行.如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示。\r\n\r\n在头部的<head>中增加第二句话，可以让网页的宽度自动适应手机屏幕的宽度。\r\n 其中： width=device-width ：表示宽度是设备屏幕的宽度 \r\n          initial-scale=1.0：表示初始的缩放比例 \r\n          maximum-scale=1.0：表示最大的缩放比例 \r\n          user-scalable=no：表示用户是否可以调整缩放比例\r\n还有一个小小的值：\r\n          minimum-scale=0.5： 表示最小的缩放比例 \r\n\r\n\r\n遇到了相同的问题的话 可以试一下！"},{"title":"使用3行CSS代码使任何元素垂直居中","content":"http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201505121820.html\r\n\r\n在页面设计中，使元素水平居中是比较简单的事情。但是如何使元素垂直居中呢？其实，我们通过3行CSS代码（不包括添加浏览器厂商所需的代码）就可以使任何元素垂直居中。秘诀就是使用transform: translateY属性，使用这种方法，哪怕是你不知道元素的高度，也可以这个元素垂直居中。CSS的transform属性通常是用来旋转或缩放元素用的，但是使用它的translateY属性，我们可以制作元素垂直居中的效果。一般我们在制作元素垂直居中效果的时候，使用的都是absolute定位，或者是设置一个元素的line-height，但是这些方法都需要预先知道元素的高度，或者是一些单行文本的情况。下面来看看实现的CSS代码（没有包括浏览器厂商的前缀代码）：.element {  position: relative;  top: 50%;  transform: translateY(-50%);}                                                          我们需要的就是这三句代码。它和绝对定位技术有一些类似，但是我们没有在元素上设置高度，或者在它的父元素上使用position属性。这种方法可以在所有的现代浏览器中正常工作，包括IE9。下面演示了几个例子：这是一个垂直居中的文本！上面的例子的代码如下：.valign-image img ,.valign-text p{  position: relative;  top: 50%;  -webkit-transform: translateY(-50%);  -ms-transform: translateY(-50%);  transform: translateY(-50%);}section.valign-image,section.valign-text{  display: block;  max-width: 500px;  background: #433669;  margin: 0 auto 1em;  height: 140px;  border-radius: .5em;  color: white;  text-align: center;} .valign-image img,.valign-text p{padding: 1em;}             \r\n                                              为了使代码的使用更加简单，减少重复工作，我们可以将它写成Sass mixin，或者一个placeholder selector，将浏览器厂商的前缀在这些代码中补全：\r\n/* Mixin */@mixin vertical-align {  position: relative;  top: 50%;  -webkit-transform: translateY(-50%);  -ms-transform: translateY(-50%);  transform: translateY(-50%);}.element p {  @include vertical-align;}/* Placeholder selector */%vertical-align {  position: relative;  top: 50%;  -webkit-transform: translateY(-50%);  -ms-transform: translateY(-50%);  transform: translateY(-50%);}.element p {  @extend %vertical-align;}   \r\n                                                        扩展其实，要使一个元素垂直居中的方法有很多，我们可以使用display:table-cell，calc，甚至是绝对定位的方法来使元素垂直居中。看下面的例子：使用display:table-cell方法使元素垂直居中：\r\n.center-aligned {     display: table;     background: hsl(120, 100%, 97%);     width: 100%; }.center-core {     display: table-cell;     text-align: center;     vertical-align: middle; }\r\n.center-core img { width: 33%; height: auto; }    \r\n\r\n        使用calc()方法使元素垂直居中：\r\n.element{  height: 250px;  width: 250px;  position: relative;  left: calc(50% – 125px);}                                                          使用绝对定位的方法使元素垂直居中：.element{  position: relative;  width: 400px;  height: 400px;  background: #6699cc;}          \r\n.element .sub-element{  position: absolute;  top: 0;  left: 0;  right: 0;  bottom: 0;  margin: auto;  width: 200px;  height: 200px;  background: #fff;}      \r\n                                                     小结\r\n使元素垂直居中的方法很多，我们要选择一种适合我们的方法来使用。本文介绍了一种使用transform: translateY来使元素垂直居中的方法，这种方法可以兼容IE9以上的浏览器。本文版权属于jQuery之家，转载请注明出处：http://www.htmleaf.com/ziliaoku/qianduanjiaocheng/201505121820.html\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"title":"不容错过的七个jQuery图片滑块插件","content":"1、jQuery多图并列焦点图插件今天我们要来分享一款比较特别的jQuery焦点图插件，它允许你自己定义当前画面的图片数量，在这个演示中，我们定义了3张图片一起显示。和其他jQuery焦点图一样，这款焦点图插件的图片下方也有一排小按钮，可以任意切换图片。另外，每张图片也都有文字描述。在线演示源码下载2、jQuery动画焦点图 可自动播放图片这是一款简单而实用的jQuery焦点图插件，焦点图不仅可以在播放图片的时候让图片有淡入淡出的动画效果，而且图片可以自动播放。该jQuery焦点图的每一张图片都可以设置文字描述，并浮动在图片之上。由于其简单的配置，这款jQuery焦点图可以很方便地与你的网站相结合。在线演示源码下载3、jQuery缩略图动态缩放焦点图今天我们要来分享一款jQuery焦点图，这款jQuery焦点图的图片切换按钮是几张图片的缩略图，鼠标滑过缩略图即可切换至相应的图片。焦点图的切换动画是图片的动态缩放，动画效果还算新颖，图片切换也比较流畅，是一款值得一试的jQuery焦点图。在线演示源码下载4、jQuery全屏滑块焦点图 可自定义内容之前我们已经分享过很多jQuery焦点图插件了，很多焦点图都非常实用，可以应用到自己的网站上去。这次要分享的也是一款基于jQuery的全屏方式滑块焦点图插件，滑块的内容可以自定义，可以是几张图片的组合，也可以是横幅广告。在线演示源码下载5、jQuery/CSS3动画相册图片浏览插件之前我们分享过一款基于jQuery的仿QQ空间相册浏览插件，功能上已经十分完善，但是缺少动画效果。今天这款jQuery相册插件正好弥补了动画的缺陷，由于CSS3特性的利用，当我们点击图片浏览的时候，缩略图就会以淡入淡出的动画效果消失，然后出现原始图片。同时你也可以点击左右按钮来逐一浏览相册中的图片。在线演示源码下载6、jQuery纵向滑块焦点图插件 图片切换流畅今天我们要来分享一款效果很酷的jQuery焦点图，它的Tab切换方式是纵向的，而且图片切换的方式也是纵向的，另外整个jQuery焦点图的色彩非常棒，给人一种神秘的感觉。焦点图的图片切换还是比较流畅的。在线演示源码下载7、jQuery/CSS3立方体翻转3D全屏焦点图今天我们要来分享一款非常大气的HTML5/CSS3 3D全屏焦点图，在页面两侧，有两个很立体的左右箭头进行图片切换。这款HTML5焦点图的图片切换方式是3D效果的，类似立方体翻转一样，焦点图默认显示文字，我们已经将文字替换成图片，效果更酷。在线演示源码下载本文固定链接: http://www.i7758.com/archives/1659.html\r\n专注前端开发，关注用户体验: http://www.i7758.com\r\nWEB前端交流中心\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"title":"优质网站推荐","content":"转载自：https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers\r\n\r\n极客标签： http://www.gbtags.com/\r\n\r\n码农周刊： http://weekly.manong.io/issues/\r\n\r\n前端周刊： http://www.feweekly.com/issues\r\n\r\n极客头条： http://geek.csdn.net/\r\n\r\nStartup News：http://news.dbanotes.net/\r\n\r\nHacker News： https://news.ycombinator.com/news\r\n\r\nInfoQ： http://www.infoq.com/\r\n\r\nw3cplus： http://www.w3cplus.com/\r\n\r\nStack Overflow： http://stackoverflow.com/\r\n\r\nAtp： http://atp-posts.b0.upaiyun.com/posts/"},{"title":"$.extend()","content":"不管说什么我喜欢先看例子，这样会更容易理解：\r\n例1：合并对象obj1和obj2，并且修改第一个对象obj1\r<!DOCTYPE>\r\n<html>\r\n<head>\r\n\t<meta charset='utf-8'>\r\n\t<title></title>\r\n\t<script src=\"https://code.jquery.com/jquery-1.10.2.js\"></script>\r\n\t<script type=\"text/javascript\">\r\n\t$(function(){\r\n\t\tvar obj1={\r\n\t\t\tname:'jxj',\r\n\t\t\tinf:{weight:120,height:173},\r\n\t\t\tlove:\"gril\"\r\n\t\t};\r\n\t\tvar obj2={\r\n\t\t\tname:'jxj2',\r\n\t\t\tinf:{height:175},\r\n\t\t\tlike:\"eat\"\r\n\t\t};\r\n\t\tvar a=$.extend(obj1, obj2);\r\n\t\tconsole.log(a);\r\n\t});\r\n\t</script>\r\n</head>\r\n<body>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n先解析一下上面代码的运行结果：\r\nObject {name: \"jxj2\", inf: Object, love: \"gril\", like: \"eat\"}\r\ninf: Object like: \"eat\"love: \"gril\"name: \"jxj2\"\r\n上面代码运行的结果是一个对象（也就是说$.extend()方法执行的结果是一个对象）\r\n这个对象有四个属性，name 、inf、love、like，其中inf属性的值是一个对象（当然数组也是一样的效果）\r\n仔细看看这结果对象中的四个属性和属性值，会发现$.extend(obj1,obj2)方法，将第二个对象中的属性和值都合并到第一个对象中了（obj1中与obj2中相同的属性将会被覆盖,obj1中没有的添加进来）\r\n注意的是obj1中的属性inf值是一个对象，这个对象中有2个属性，可是却被obj2中的一个属性全部覆盖，这不是我们要的结果，我希望是obj1中的inf属性值还保持2个，只是这二个中与obj2中的相同部分被覆盖而已。\r\n\r\n例2：：递归合并对象obj1和obj2，并且修改第一个对象obj1\r<!DOCTYPE>\r\n<html>\r\n<head>\r\n\t<meta charset='utf-8'>\r\n\t<title></title>\t\r\n\t<script src=\"https://code.jquery.com/jquery-1.10.2.js\"></script>\r\n\t<script type=\"text/javascript\">\r\n\t$(function(){\r\n\t\tvar obj1={\r\n\t\t\tname:'jxj',\r\n\t\t\tinf:{weight:120,height:173},\r\n\t\t\tlove:\"gril\"\r\n\t\t};\r\n\t\tvar obj2={\r\n\t\t\tname:'jxj2',\r\n\t\t\tinf:{height:175},\r\n\t\t\tlike:\"eat\"\r\n\t\t};\r\n\t\tvar a=$.extend(true,obj1, obj2);\r\n\t\tconsole.log(a);\r\n\t});\r\n\t</script>\r\n</head>\r\n<body>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n上面的例子运行结果如下：\r\n\r\nObject {name: \"jxj2\", inf: Object, love: \"gril\", like: \"eat\"}\r\ninf: Objectheight: 175weight: 120\r\n上面例子和第一个例子只有一个参数的却别，其它都是一样的，但是结果确是不一样的，不一样的是obj1中的属性值为对象的属性，值有二个了，之前是一个\r\n其它不解释，同第一个例子。\r\n\r\n\r\n例3：递归合并对象obj1和obj2，但是不修改第一个对象obj1\r<!DOCTYPE>\r\n<html>\r\n<head>\r\n\t<meta charset='utf-8'>\r\n\t<title></title>\t\r\n\t<script src=\"https://code.jquery.com/jquery-1.10.2.js\"></script>\r\n\t<script type=\"text/javascript\">\r\n\t$(function(){\r\n\t\tvar obj1={\r\n\t\t\tname:'jxj',\r\n\t\t\tinf:{weight:120,height:173},\r\n\t\t\tlove:\"gril\"\r\n\t\t};\r\n\t\tvar obj2={\r\n\t\t\tname:'jxj2',\r\n\t\t\tinf:{height:175},\r\n\t\t\tlike:\"eat\"\r\n\t\t};\r\n\t\tvar a=$.extend(true,{},obj1, obj2);\r\n\t\tconsole.log(a);\r\n\t\tconsole.log(JSON.stringify(obj1));\r\n\t\tconsole.log(JSON.stringify(obj2));\r\n\t\tconsole.log(JSON.stringify(a));\r\n\t});\r\n\t</script>\r\n</head>\r\n<body>\r\n</body>\r\n</html>运行代码复制代码保存代码提示：您可以先修改部分代码再运行!power by W3Cfuns.com\n上面的例子运行结果为：\r\n Object {name: \"jxj2\", inf: Object, love: \"gril\", like: \"eat\"}\r\ninf: Objectheight: 175weight: 120\r\n{\"name\":\"jxj\",\"inf\":{\"weight\":120,\"height\":173},\"love\":\"gril\"}\r\n{\"name\":\"jxj2\",\"inf\":{\"height\":175},\"like\":\"eat\"}\r\n{\"name\":\"jxj2\",\"inf\":{\"weight\":120,\"height\":175},\"love\":\"gril\",\"like\":\"eat\"}\r\n这次我在$.extend(true,{},obj1, obj2)中又加了一个参数｛｝，也就是在第一个对象参数上加了一个空的对象\r\n\r\n\r\n如果仔细看了上面的三个例子，并且分析结果和区别，那么$extend()方法已经会使用了\r\n\r\n\r\n说了例子，现在才开始说语法：\r\njQuery.extend([deep，] obj[, object1 ] [, objectN ] )\r\n该方法是将多个对象[，obj1][，objN].....合并到第一个对象（此时的第一对象不为空）\r\ndeep是可选参数，当是true时表示深度合并或是递归合并，这里的作用是为了不让obj对象中属性值是对象或是数组的属性值全部被覆盖掉，只需要覆盖掉相同的就可以了\r\ntarget 被扩展的对象，等待其它对象obj1，obj2....来扩展它。   如果只有obj这一个参数，而没有其它扩展参数，则默认jquery是被扩展对象，通过obj将扩展jquery命名空间。\r\nobj1。。。。。。将自己对象属性合并到第一个对象参数（obj）中去\r\n\r\n好像还有一个没介绍\r\njQuery.extend([deep，] [,{}]obj[, object1 ] [, objectN ] )\r\n当第一个对象参数是空（｛｝）的时候，表示合并，但是不会改变被合并的对象，我们可以在想保留源对象obj的时候来使用\r\n"},{"title":"Git命令大全","content":"关联用户：$ git config --global user.name \"yourName\"\r\n关联邮箱账号：$ git config --global user.email \"yourEmail\"\r\n创建新文件夹：$ mkdir <file>\r\n显示当前目录：$ pwd\r\n将某个目录变成Git仓库：$ git init\r\n将文件添加到仓库：$ git add <file>\r\n把文件提交到仓库，-m后面输入的是本次提交的说明：$ git commit -m \"wrote a readme file\"\r\n显示仓库当前的状态：$ git status\r\n查看文件的修改内容：$ git diff <file>\r\n查看提交历史：$ git log\r\n单行显示提交历史：$ git log --pretty=oneline\r\n把当前版本回退到上一个版本：$ git reset --hard HEAD^\r\n查看 readme.txt 文件的内容：$ cat readme.txt\r\n回退到某一版本[例如3628164]：$ git reset --hard 3628164\r\n查看命令历史：$ git reflog\r\n查看文件工作区和版本库里最新版本的区别：$ git diff HEAD -- <file>\r\n丢弃文件工作区的修改：$ git checkout -- <file>\r\n把文件暂存区的修改回退到工作区：$ git reset HEAD <file>\r\n删除文件：$ rm <file>\r\n创建SSH Key：$ ssh-keygen -t rsa -C \"yourEmail\"\r\n建立本地仓库与GitHub远程仓库的关联：$ git remote add origin git@github.com:GitHubName/<file>.git\r\n                                              或者：$ git remote add origin https://github.com/GitHubName/<file>.git\r\n把本地库的内容推送到远程，加-u参数，把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令：$ git push -u origin master\r\n简化后的推送命令：$ git push origin master\r\n从GitHub远程仓库克隆：$ git clone git@github.com:GitHubName/<file>.git\r\n                          或者：$ git clone https://github.com/GitHubName/<file>.git\r\n查看文件列表：$ ls\r\n创建“dev”分支：$ git branch dev\r\n切换到“dev”分支：$ git checkout dev\r\n创建“dev”分支并且切换到“dev”分支：$ git checkout -b dev\r\n列出所有分支，当前分支前面会标一个*号：$ git branch\r\n合并“dev”分支到当前分支：$ git merge dev\r\n删除dev分支：$ git branch -d dev\r\n用带参数的 git log 查看分支的合并情况：$ git log --graph --pretty=oneline --abbrev-commit\r\n--no-ff参数，表示禁用Fast forward，因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去：$ git merge --no-ff -m \"merge with no-ff\" dev\r\n把当前工作现场“储藏”起来：$ git stash\r\n查看储藏的工作现场列表：$ git stash list\r\n恢复“储藏”的工作现场同时把stash内容也删除：$ git stash pop\r\n恢复“储藏”的工作现场但不删除stash内容，需要用git stash drop来删除：$ git stash apply\r\n丢弃一个没有被合并过的“dev”分支：$ git branch -D dev\r\n查看远程库的信息：$ git remote\r\n查看远程库的详细信息：$ git remote -v\r\n推送“dev”分支到远程：$ git push origin dev\r\n在本地创建dev和远程分支对应的dev分支：$ git checkout -b dev origin/dev\r\n指定本地dev分支与远程origin/dev分支的链接：$ git branch --set-upstream dev origin/dev\r\n抓取分支：$ git pull\r\n打一个新标签v1.0：$ git tag v1.0\r\n查看所有标签：$ git tag\r\n对某一 commit id(例如6224937) 打标签：$ git tag v0.9 6224937\r\n查看v0.9标签信息：$ git show v0.9\r\n创建带有说明的标签，用-a指定标签名，-m指定说明文字，3628164为示例commit id：$ git tag -a v0.1 -m \"version 0.1 released\" 3628164\r\n通过-s用私钥签名一个标签：$ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\r\n删除本地v0.1标签：$ git tag -d v0.1\r\n推送v1.0标签到远程：$ git push origin v1.0\r\n一次性推送全部尚未推送到远程的本地标签：$ git push origin --tags\r\n删除本地v0.9标签：$ git tag -d v0.9\r\n删除远程v0.9标签：$ git push origin :refs/tags/v0.9\r\n让Git显示颜色：$ git config --global color.ui true\r\n配置st为status的别名：$ git config --global alias.st status\r\n"},{"title":"超赞值得一试的六款jQuery插件和CSS3应用","content":"[size=13.333333015441895px]1、jQuery图片横向滚动插件这是一款利用jQuery实现的图片横向滚动插件，我们可以设置任意数量的图片，然后点击左右箭头按钮即可分组浏览这些图片。这款jQuery图片插件的优势有两点，其一是可以定义每组图片的数量，其二是图片可循环播放，而且简单实用。在线演示源码下载2、实时更新数据的jQuery highcharts图表插件今天我们要来分享一款基于jQuery的highcharts实时图表插件，highcharts图表插件定义了每隔一秒钟更新数据，然后根据每个数据点绘制一条折线，随着数据的更新，折线也就会不停的向前移动，形成一个类似CPU实时监控的曲线图表。这款jQuery图表插件应用比较广泛，兼容所有浏览器。在线演示源码下载3、CSS3个性化价格表 自定义表格单元这是一款基于CSS3的个性化表格应用，它从某网站的价格表，看起来表格设计非常新颖。演示中价格表的圆形、圆角等效果均通过CSS3实现，这款CSS3价格表外观非常清新，并且留有很自然的投影和变现处理效果。在线演示源码下载4、jQuery弹出登录表单窗口插件这是一款基于jQuery的登录表单插件，有一点特别的是该登录表单是一个弹出层窗口，表单即嵌在这个窗口里面，并且弹出层还有一层遮罩将网页的其他部分遮盖住。表单在弹出的时候利用jQuery的动画特性将会出现淡入淡出的迷人效果。在线演示源码下载5、CSS3个人博客菜单动画 简洁的菜单样式这是一款基于纯CSS3的菜单导航，由于它简洁的外观样式，所以可以用来做个人博客的菜单导航。这款CSS3菜单采用的是黑色的背景，当鼠标滑过菜单项时，背景颜色就会变成渐变的蓝色，色彩搭配非常合理，并且在鼠标滑过是带有向上滑动的动画效果。在线演示源码下载6、CSS3仿wordpress网站后台管理菜单导航这次要分享的是一款CSS3仿wordpress后台管理菜单导航，用过wordpress的朋友应该比较熟悉，它后台管理的菜单是纵向的，并且菜单项都有小图标。这款菜单就用CSS3来实现了wordpress后台风格的菜单样式，适合在你的网站后台使用，非常实用。在线演示源码下载本文固定链接: http://www.i7758.com/archives/1656.html\r\n[size=13.333333015441895px]专注前端开发，关注用户体验: http://www.i7758.com\r\nWEB前端交流中心\r\n"},{"title":"js性能优化，收藏!","content":"通过网上查找资料了解关于性能优化方面的内容，现简单整理，仅供大家在优化的过程中参考使用，如有什么问题请及时提出，再做出相应的补充修改。 \r\n\r\n一、 让代码简洁：一些简略的表达方式也会产生很好的优化 \r\n\r\neg：x=x+1;在不影响功能的情况下可以简写为x++; \r\n\r\n二、 变量名方法名尽量在不影响语意的情况下简单。（可以选择首字母命名） \r\n\r\neg：定义数组的长度可以取名为：ArrLen而不需要取为ArrayLength。 \r\n\r\n三、 关于JS的循环，循环是一种常用的流程控制。 \r\n\r\nJS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。当然，推荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或–运算符。 \r\n\r\n四、 如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。 \r\n\r\n因为我们常常要根据字符串、数组的长度进行循环，而通常这个长度是不变的，比如每次查询a.length，就要额外进行一个操作，而预先把var len=a.length，则就少了一次查询。 \r\n\r\n五、 尽量选用局部变量而不是全局变量。 \r\n\r\n局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。 \r\n\r\n六、 尽量少使用eval。 \r\n\r\n每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。 \r\n\r\n七、 减少对象查找 \r\n\r\n因为JavaScript的解释性，所以a.b.c.d.e，需要进行至少4次查询操作，先检查a再检查a中的b，再检查b中的c，如此往下。所以如果这样的表达式重复出现，只要可能，应该尽量少出现这样的表达式，可以利用局部变量，把它放入一个临时的地方进行查询。 \r\n\r\n八、 字符串连接。 \r\n\r\n如果是追加字符串，最好使用s+=anotherStr操作，而不是要使用s=s+anotherStr。 \r\n\r\n如果要连接多个字符串，应该少使用+=，如s+=a;s+=b;s+=c;应该写成s+=a + b + c； \r\n而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存。怎么用呢？使用JavaScript数组来收集，最后使用join方法连接起来，如下 \r\n复制代码 代码如下:\r\n\r\nvar buf = new Array();for(var i = 0; i < 100; i++){ buf.push(i.toString());}var all = buf.join(\"\"); \r\n\r\n九、 类型转换 \r\n\r\n1. 把数字转换成字符串，应用\"\" + 1，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：(\"\" +) > String() > .toString() > new String() \r\n\r\n尽量使用编译时就能使用的内部操作要比运行时使用的用户操作要快。 \r\n\r\nString()属于内部函数，所以速度很快，而.toString()要查询原型中的函数，所以速度逊色一些，new String()用于返回一个精确的副本。 \r\n\r\n2. 浮点数转换成整型，这个更容易出错，很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()。Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用的时间，速度是最快的。 \r\n\r\n3. 对于自定义的对象，如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高 \r\n\r\n十、 尽量作用JSON格式来创建对象，而不是var obj=new Object()方法。 \r\n\r\n因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。 \r\n\r\n十一、 当需要使用数组时，也尽量使用JSON格式的语法， \r\n\r\n使用JSON格式的语法即直接使用如下语法定义数组：[parrm,param,param...],而不是采用new Array(parrm,param,param...)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。 \r\n\r\n十二、 对字符串进行循环操作，例如替换、查找，就使用正则表达式。 \r\n\r\n因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。 \r\n\r\n十三、 插入HTML \r\n\r\n很多人喜欢在JavaScript中使用document.write来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。 \r\n\r\n十四、 对象查询 \r\n\r\n使用[“”]查询要比.items()更快 \r\n\r\n十五、 定时器 \r\n\r\n如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval。setTimeout每次要重新设置一个定时器。 \r\n\r\n十六、 尽量减少DOM调用 \r\n\r\n在Web开发中，JavaScript的一个很重要的作用就是对DOM进行操作。可是对DOM的操作是非常昂贵的，因为这会导致浏览器执行回流 （reflow）操作。我们应该尽可能的减少DOM操作。 \r\n回流操作主要会发生在几种情况下： \r\n* 改变窗体大小 \r\n* 更改字体 \r\n* 添加移除stylesheet块 \r\n* 内容改变哪怕是输入框输入文字 \r\n* CSS虚类被触发如 :hover \r\n* 更改元素的className \r\n* 当对DOM节点执行新增或者删除操作或内容更改时。 \r\n* 动态设置一个style样式时（比如element.style.width=\"10px\"）。 \r\n* 当获取一个必须经过计算的尺寸值时，比如访问offsetWidth、clientHeight或者其他需要经过计算的CSS值 \r\n解决问题的关键，就是限制通过DOM操作所引发回流的次数: \r\n1.在对当前DOM进行操作之前，尽可能多的做一些准备工作，保证N次创建，1次写入。 \r\n2.在对DOM操作之前，把要操作的元素，先从当前DOM结构中删除： \r\n2.1. 通过removeChild()或者replaceChild()实现真正意义上的删除。 \r\n2.2. 设置该元素的display样式为“none”。 \r\n\r\n3.CSS部分 \r\n另外一个经常引起回流操作的情况是通过style属性对元素的外观进行修改，如element.style.backgroundColor = \"blue\"; \r\n每次修改元素的style属性，都肯定会触发回流操作，要解决这个问题可以： \r\n3.1.使用更改className的方式替换style.xxx=xxx的方式。 \r\n3.2.使用style.cssText = '';一次写入样式。 \r\n3.3. 避免设置过多的行内样式 \r\n3.4. 添加的结构外元素尽量设置它们的位置为fixed或absolute \r\n3.5. 避免使用表格来布局 \r\n3.6. 避免在CSS中使用JavaScript expressions(IE only) \r\n4.将获取的DOM数据缓存起来。这种方法，对获取那些会触发回流操作的属性（比如offsetWidth等）尤为重要。 \r\n5.当对HTMLCollection对象进行操作时，应该将访问的次数尽可能的降至最低，最简单的，你可以将length属性缓存在一个本地变量中，这样就能大幅度的提高循环的效率。 \r\n\r\n十七、 重构<script>和<style> 调用方式或合并js文件来优化请求次数，并尽量使用外部链接方式引用 \r\n\r\n我们常常在一个HTML文件头中看到这样标记代码: \r\n\r\n<script src=\"/scripts/a.js\"></script> \r\n\r\n<script src=\"/scripts/b.js\"></script> \r\n\r\n<script src=\"/scripts/c.js\"></script> \r\n\r\n大多是情况下，上述代码可以被简化成： \r\n\r\n<script src=\"/ scripts /d.js\"></script> \r\n\r\n其中d.js中引用了a.js/b.js/c.js。通过document.write方法写入。 \r\n\r\n十八、 对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。 \r\n\r\n十九、 将脚本放到底部。 \r\n\r\n脚本一般是用来于用户交互的，建议可以等页面加载完成之后再加载js文件。所以，脚本和CSS正好相反，脚本应该放在页面的底部。 \r\n\r\n二十、 除去JavaScript中的空白区域 \r\n\r\n可以用相关工具去除空白注释等,将所有的名称都重新用一个或两个字母来命名将带来显著的改善。（但需要留有一个未验收的备份文件，方便以后维护）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n最后，总结下常见的dom操作的优化方法（节选自高性能JavaScript）\r\n\r\n     1  最小化dom访问次数，尽可能在js端执行；\r\n     2  如果需要多次访问某个dom节点，请使用局部变量存储对它的引用；\r\n     3  小心处理html集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中；\r\n     4  如果可能的话，使用速度更快的API，比如querySelectorAll和firstElementChild；\r\n     5  要留意重绘和重排；批量修改样式时，“离线”操作dom树；使用缓存，并减少访问布局的次数；\r\n     6  动画中使用绝对定位，使用拖放代理\r\n     7  使用事件委托来减少事件处理器的数量\r\n\r\n     总结下js中对数据访问的优化（节选自高性能JavaScript）\r\n\r\n     1  函数中读写局部变量总是最快的，而全局变量的读取则是最慢的；\r\n     2  尽可能地少用with 语句，因为它会增加with 语句以外的数据的访问代价；\r\n     3  闭包尽管强大，但不可滥用，否则会影响到执行速度以及内存；\r\n     4  嵌套的对象成员会明显影响性能，尽量少用；\r\n     5  避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存。"},{"title":"sublime 快捷键","content":"插件使用方法：Ctrl+Shift+P 调用命令面板，我们就会找到一些以“Package Control:”开头的命令，我们常用到的就是几个 Install Package (安装扩展)、List Packages (列出全部扩展)、Remove Package (移除扩展)、Upgrade Package (升级扩展)\r\nCtrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）\r\nCtrl+G 跳转到相应的行\r\nCtrl+J 合并行（已选择需要合并的多行时）\r\nCtrl+L 选择整行（按住-继续选择下行）\r\nCtrl+M 光标移动至括号内开始或结束的位置\r\nCtrl+T 词互换\r\nCtrl+U 软撤销\r\nCtrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；\r\nCtrl+R 快速列出/跳转到某个函数\r\nCtrl+K Backspace 从光标处删除至行首\r\nCtrl+KB 开启/关闭侧边栏\r\nCtrl+KK 从光标处删除至行尾\r\nCtrl+KT 折叠属性\r\nCtrl+KU 改为大写\r\nCtrl+KL 改为小写\r\nCtrl+K0 展开所有\r\nCtrl+Enter 插入行后（快速换行）\r\nCtrl+Tab 当前窗口中的标签页切换\r\nCtrl+Shift+A 选择光标位置父标签对儿\r\nCtrl+Shift+D 复制光标所在整行，插入在该行之前\r\nctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找\r\nCtrl+Shift+K 删除整行\r\nCtrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行\r\nCtrl+Shift+M 选择括号内的内容（按住-继续选择父括号）\r\nCtrl+Shift+P 打开命令面板\r\nCtrl+Shift+/ 注释已选择内容\r\nCtrl+Shift+↑可以移动此行代码，与上行互换\r\nCtrl+Shift+↓可以移动此行代码，与下行互换\r\nCtrl+Shift+[ 折叠代码\r\nCtrl+Shift+] 展开代码\r\nCtrl+Shift+Enter 光标前插入行\r\nCtrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换\r\nCtrl+Z 撤销\r\nCtrl+Y 恢复撤销\r\nCtrl+F2 设置书签\r\nCtrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）\r\nCtrl+鼠标左键 可以同时选择要编辑的多处文本\r\nShift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择\r\nShift+F2 上一个书签\r\nShift+Tab 去除缩进\r\nAlt+Shift+1~9（非小键盘）屏幕显示相等数字的小窗口\r\nAlt+. 闭合当前标签\r\nAlt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑\r\nTab 缩进 自动完成\r\nF2 下一个书签\r\nF9 行排序(按a-z)\r\nF11 全屏模式"},{"title":"css深入理解浮动","content":"浮动是原先设计为了实现文字环绕效果，具有包裹性和破坏性，包裹性体现在宽度收缩，高度坚挺，与外界隔绝。破坏性体现在父元素高度塌陷，影响其他元素，浮动元素脱离的文档流。浮动也使元素block化，去空格化。\r\n清除浮动带来的影响有二种方式：\r\n1.添加clear：both，但是引入无意义标签。\r\n2.父元素bfc：.clear:after{content:\"\";display:table;clear:both;} .clearfix{*zoom:1;}\r\n\r\nCSS深入理解之float浮动\r\n\r\nfloat设计初衷仅仅是为了实现文字环绕效果\r\n明白float设计初衷可以很好的理解float特有的行为表现\r\n\r\nfloat的包裹与破坏\r\n\r\n如何理解包裹\r\n包裹性的理解：收缩（宽度），坚挺（高度），隔绝（对外界没有影响）\r\nBFC-块级格式化上下文\r\n具有包裹性小伙伴\r\ndisplay：inline-block/table-cell\r\nposition:absolute（近亲）/fixed/stick\r\noverflow:hidden/scroll\r\n\r\n破坏性：\r\ndisplay:none\r\nposition:absolute/fixed\r\n浮动带来破坏其他小伙伴\r\n\r\n浮动具有破坏性，可以使父元素的高度塌陷\r\n如何理解浮动让父元素高度塌陷的bug，首先浮动使高度塌陷不是bug，而是标准\r\n浮点的原本作业仅仅是实现文字环绕效果。使用破坏css盒模型。\r\n\r\n当对图片实行float:left 图片从inline boxes 链上脱离，受自身方位属性的影响，靠左显示，由于其“包裹性”，宽度实体依旧存在，加上与文字处于同一文档流中，文字不会与图片位置重叠，加上图片没有inline boxes，高度丢失，所以文字居顶显示。\r\n\r\n清楚浮动带来的影响：\r\n方法一：脚底插入clear:both\r\n方法二：overflow + zoom方法\r\n.fix{overflow:hidden; zoom:1;}\r\n优点在于代码简洁，涵盖所有浏览器，可谓不错的选择啊。不过也是有问题的，就是这个overflow:hidden;是个小炸蛋，要是里面的元素要是想来个margin负值定位或是负的绝对定位，岂不是直接被裁掉了，所以此方法是有不小的局限性的\r\n方法三：父元素 BFC 或 haslayout\r\n二种方法的差异：\r\nclear就像是索桥，二种通常应用格式：1.html block 水平元素底部走起 <div></div> 2.css after 伪元素底部走起 .clearfix:after{}\r\nBFC/haslayout 就像是封闭空间\r\n\r\n二种方法不足：\r\n*脚本插入div：裸露的div很讨厌 div标签看上去很讨厌\r\n*after伪元素：IE6,7不认识  这也是IE6 7经常崩溃的原因\r\n如果想适用于各种场景，BFC各个声明是不可以的，不是所有元素都浮动，或者绝对定位，但zoom:1 却是可以的，但是现在浏览器目前大部分不认可，才有一个权衡的策略。\r\nclearfix:after { content: ''; display: block; height: 0; overflow: hidden; clear: both; }\r\n.clearfix { *zoom: 1; }\r\n更好方法：\r\n.clearfix:after { content: ''; display: table; clear: both; }\r\n.clearfix { *zoom: 1; }\r\n使用display:table 代码更加精简\r\n\r\n切勿滥用，clearfix应用在包含浮动子元素的父级元素上。\r\n\r\n\r\nBFC/haslayout声明：\r\nfloat:left/right\r\nposition:absolute/fixed\r\noverflow:hidden/scroll\r\ndisplay:inline-block/table-cell\r\nwidth,height:zoom:1(IE6,7) zoom:1 让IE6/7 haslayout 又不会影响形体的神器。\r\n\r\n**处理方法：\r\n.fix{content:\"\";display:table;clear:both;}\r\n.fix{*zoom:1};\r\n该元素使用在父元素上。\r\n记住haslayout往往会使IE6,7做出更加出格的事情，浮动也会触发haslayout，浮动在IE6、7下更显魔性避免浮动的滥用。\r\n\r\ninline-block:button img\r\n**float的block化和破坏性\r\n元素block化，即砖头化 display:block\r\n破坏性造成的紧密排列特性，即空格化: 去空格化 将空格在浮点元素之后。\r\n\r\n问题在于：\r\n1.容错性比较槽糕，容易出问题 很容易发错错位。\r\n2.布局需要元素固定尺寸，很难重复使用 需要元素固定尺寸，很难重用\r\n3.低版本的IE会有很多问题 在低版本ie下有很多问题\r\n\r\n如何借助浮点实现流体布局：\r\n文字环绕：\r\n对图片设置width+float+padding-left/margin-left\r\n对右侧的div设置display:table-cell\r\n\r\n让IE7下浮动问题\r\n1.含clear浮动元素包裹不正确的问题 \r\n2.浮动元素倒数2个莫名的垂直间距问题\r\n3.浮动元素最后一个字符重复问题\r\n4.浮动元素楼梯排列问题\r\n5.浮动元素和文本不在同一行问题(左侧标题左浮动，右侧标题右浮动)\r\n\r\n总之合理使用float，且用且珍惜\r\n\r\n\r\n对overflow与zoom”清除浮动”的一些认识\r\n浮动：宽度包裹与内部的元素，浮动的包裹性显而易见。\r\nabsolute：即absolute元素（如果没有设置width值），其宽度自适应于内部元素\r\ninline-block：包裹性\r\noverflow的包裹性其实不难理解，直接隐藏超出高度的部分。IE7/IE8下overflow:hidden可以清除浮动造成的影响。\r\n\r\n由于zoom为IE私有属性，比例缩放，跟CSS3中transform:scale;作用一样（表现有些许差异）\r\n“包裹”与“清除浮动\r\n1.float:left\r\n2.position:absolute\r\n3.display:inline-block\r\n4.overflow:hidden\r\n5.zoom:1\r\n\r\n\r\n\r\n\r\n  \r\n"}]